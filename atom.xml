<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dingdingtao.github.io</id>
    <title>dingdingtao的个人静态网站</title>
    <updated>2021-03-10T10:01:17.524Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dingdingtao.github.io"/>
    <link rel="self" href="https://dingdingtao.github.io/atom.xml"/>
    <subtitle>快快长大</subtitle>
    <logo>https://dingdingtao.github.io/images/avatar.png</logo>
    <icon>https://dingdingtao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, dingdingtao的个人静态网站</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript常用正则]]></title>
        <id>https://dingdingtao.github.io/post/javascript-chang-yong-zheng-ze/</id>
        <link href="https://dingdingtao.github.io/post/javascript-chang-yong-zheng-ze/">
        </link>
        <updated>2021-03-10T08:28:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="url">URL</h3>
<pre><code class="language-javascript">let url_reg = /(http[s]?:\/\/)?[^\s([&quot;&lt;,&gt;]*\.[^\s[&quot;,&gt;&lt;]*/
</code></pre>
<h3 id="纯数字">纯数字</h3>
<pre><code class="language-javascript">let num_reg = /^[0-9]*$/
</code></pre>
<h3 id="邮箱">邮箱</h3>
<pre><code class="language-javascript">let mail_reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/
</code></pre>
<h3 id="中文与全角符号">中文与全角符号</h3>
<pre><code class="language-javascript">let chinese_reg = /[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]/
</code></pre>
<h3 id="身份证不验证是否合法">身份证(不验证是否合法)</h3>
<pre><code class="language-javascript">let idcard_reg = /\d{15}(\d\d[0-9xX])?/
</code></pre>
<h3 id="仅包含英文字母的字符串">仅包含英文字母的字符串</h3>
<pre><code class="language-javascript">let eng_reg = /^[A-Za-z]+$/
</code></pre>
<h3 id="正整数">正整数</h3>
<pre><code class="language-javascript">let digital_reg = /^\d+$/
</code></pre>
<h3 id="负整数">负整数</h3>
<pre><code class="language-javascript">let digital_reg = /^((-\d+)|(0+))$/
</code></pre>
<h3 id="数字正负数-小数">数字(正负数、小数)</h3>
<pre><code class="language-javascript">let digital_reg = /^(\-|\+)?\d+(\.\d+)?$/
</code></pre>
<h3 id="ipv4">IPv4</h3>
<pre><code class="language-javascript">let ipv4_reg = /^((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}$/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maven-POM标签大全详解]]></title>
        <id>https://dingdingtao.github.io/post/maven-pom-biao-qian-da-quan-xiang-jie/</id>
        <link href="https://dingdingtao.github.io/post/maven-pom-biao-qian-da-quan-xiang-jie/">
        </link>
        <updated>2021-03-03T06:39:47.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-XML">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
    &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 
        version。 --&gt;
    &lt;parent&gt;
        &lt;!--被继承的父项目的构件标识符 --&gt;
        &lt;artifactId /&gt;
        &lt;!--被继承的父项目的全球唯一标识符 --&gt;
        &lt;groupId /&gt;
        &lt;!--被继承的父项目的版本 --&gt;
        &lt;version /&gt;
        &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 
            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;
        &lt;relativePath /&gt;
    &lt;/parent&gt;
    &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;
    &lt;groupId&gt;asia.banseon&lt;/groupId&gt;
    &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 
        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;
    &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;
    &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;!--项目的名称, Maven产生的文档用 --&gt;
    &lt;name&gt;banseon-maven&lt;/name&gt;
    &lt;!--项目主页的URL, Maven产生的文档用 --&gt;
    &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;
    &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 
        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;
    &lt;description&gt;A maven project to study maven.&lt;/description&gt;
    &lt;!--描述了这个项目构建环境中的前提条件。 --&gt;
    &lt;prerequisites&gt;
        &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;
        &lt;maven /&gt;
    &lt;/prerequisites&gt;
    &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;
    &lt;issueManagement&gt;
        &lt;!--问题管理系统（例如jira）的名字， --&gt;
        &lt;system&gt;jira&lt;/system&gt;
        &lt;!--该项目使用的问题管理系统的URL --&gt;
        &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;
    &lt;/issueManagement&gt;
    &lt;!--项目持续集成信息 --&gt;
    &lt;ciManagement&gt;
        &lt;!--持续集成系统的名字，例如continuum --&gt;
        &lt;system /&gt;
        &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;
        &lt;url /&gt;
        &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;
        &lt;notifiers&gt;
            &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;
            &lt;notifier&gt;
                &lt;!--传送通知的途径 --&gt;
                &lt;type /&gt;
                &lt;!--发生错误时是否通知 --&gt;
                &lt;sendOnError /&gt;
                &lt;!--构建失败时是否通知 --&gt;
                &lt;sendOnFailure /&gt;
                &lt;!--构建成功时是否通知 --&gt;
                &lt;sendOnSuccess /&gt;
                &lt;!--发生警告时是否通知 --&gt;
                &lt;sendOnWarning /&gt;
                &lt;!--不赞成使用。通知发送到哪里 --&gt;
                &lt;address /&gt;
                &lt;!--扩展配置项 --&gt;
                &lt;configuration /&gt;
            &lt;/notifier&gt;
        &lt;/notifiers&gt;
    &lt;/ciManagement&gt;
    &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;
    &lt;inceptionYear /&gt;
    &lt;!--项目相关邮件列表信息 --&gt;
    &lt;mailingLists&gt;
        &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;
        &lt;mailingList&gt;
            &lt;!--邮件的名称 --&gt;
            &lt;name&gt;Demo&lt;/name&gt;
            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
            &lt;post&gt;banseon@126.com&lt;/post&gt;
            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
            &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;
            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
            &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;
            &lt;!--你可以浏览邮件信息的URL --&gt;
            &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;
        &lt;/mailingList&gt;
    &lt;/mailingLists&gt;
    &lt;!--项目开发者列表 --&gt;
    &lt;developers&gt;
        &lt;!--某个项目开发者的信息 --&gt;
        &lt;developer&gt;
            &lt;!--SCM里项目开发者的唯一标识符 --&gt;
            &lt;id&gt;HELLO WORLD&lt;/id&gt;
            &lt;!--项目开发者的全名 --&gt;
            &lt;name&gt;banseon&lt;/name&gt;
            &lt;!--项目开发者的email --&gt;
            &lt;email&gt;banseon@126.com&lt;/email&gt;
            &lt;!--项目开发者的主页的URL --&gt;
            &lt;url /&gt;
            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;
            &lt;roles&gt;
                &lt;role&gt;Project Manager&lt;/role&gt;
                &lt;role&gt;Architect&lt;/role&gt;
            &lt;/roles&gt;
            &lt;!--项目开发者所属组织 --&gt;
            &lt;organization&gt;demo&lt;/organization&gt;
            &lt;!--项目开发者所属组织的URL --&gt;
            &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;
            &lt;!--项目开发者属性，如即时消息如何处理等 --&gt;
            &lt;properties&gt;
                &lt;dept&gt;No&lt;/dept&gt;
            &lt;/properties&gt;
            &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;
            &lt;timezone&gt;-5&lt;/timezone&gt;
        &lt;/developer&gt;
    &lt;/developers&gt;
    &lt;!--项目的其他贡献者列表 --&gt;
    &lt;contributors&gt;
        &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;
        &lt;contributor&gt;
            &lt;name /&gt;
            &lt;email /&gt;
            &lt;url /&gt;
            &lt;organization /&gt;
            &lt;organizationUrl /&gt;
            &lt;roles /&gt;
            &lt;timezone /&gt;
            &lt;properties /&gt;
        &lt;/contributor&gt;
    &lt;/contributors&gt;
    &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;
    &lt;licenses&gt;
        &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;
        &lt;license&gt;
            &lt;!--license用于法律上的名称 --&gt;
            &lt;name&gt;Apache 2&lt;/name&gt;
            &lt;!--官方的license正文页面的URL --&gt;
            &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;
            &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;
            &lt;distribution&gt;repo&lt;/distribution&gt;
            &lt;!--关于license的补充信息 --&gt;
            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;
        &lt;/license&gt;
    &lt;/licenses&gt;
    &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;
    &lt;scm&gt;
        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;
        &lt;connection&gt;
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
        &lt;/connection&gt;
        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;
        &lt;developerConnection&gt;
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
        &lt;/developerConnection&gt;
        &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;
        &lt;tag /&gt;
        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;
        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;
    &lt;/scm&gt;
    &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;
    &lt;organization&gt;
        &lt;!--组织的全名 --&gt;
        &lt;name&gt;demo&lt;/name&gt;
        &lt;!--组织主页的URL --&gt;
        &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;
    &lt;/organization&gt;
    &lt;!--构建项目需要的信息 --&gt;
    &lt;build&gt;
        &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;
        &lt;sourceDirectory /&gt;
        &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;
        &lt;scriptSourceDirectory /&gt;
        &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;
        &lt;testSourceDirectory /&gt;
        &lt;!--被编译过的应用程序class文件存放的目录。 --&gt;
        &lt;outputDirectory /&gt;
        &lt;!--被编译过的测试class文件存放的目录。 --&gt;
        &lt;testOutputDirectory /&gt;
        &lt;!--使用来自该项目的一系列构建扩展 --&gt;
        &lt;extensions&gt;
            &lt;!--描述使用到的构建扩展。 --&gt;
            &lt;extension&gt;
                &lt;!--构建扩展的groupId --&gt;
                &lt;groupId /&gt;
                &lt;!--构建扩展的artifactId --&gt;
                &lt;artifactId /&gt;
                &lt;!--构建扩展的版本 --&gt;
                &lt;version /&gt;
            &lt;/extension&gt;
        &lt;/extensions&gt;
        &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;
        &lt;defaultGoal /&gt;
        &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;
        &lt;resources&gt;
            &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;
            &lt;resource&gt;
                &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 
                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;
                &lt;targetPath /&gt;
                &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;
                &lt;filtering /&gt;
                &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;
                &lt;directory /&gt;
                &lt;!--包含的模式列表，例如**/*.xml. --&gt;
                &lt;includes /&gt;
                &lt;!--排除的模式列表，例如**/*.xml --&gt;
                &lt;excludes /&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;
        &lt;testResources&gt;
            &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;
            &lt;testResource&gt;
                &lt;targetPath /&gt;
                &lt;filtering /&gt;
                &lt;directory /&gt;
                &lt;includes /&gt;
                &lt;excludes /&gt;
            &lt;/testResource&gt;
        &lt;/testResources&gt;
        &lt;!--构建产生的所有文件存放的目录 --&gt;
        &lt;directory /&gt;
        &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --&gt;
        &lt;finalName /&gt;
        &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;
        &lt;filters /&gt;
        &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;
        &lt;pluginManagement&gt;
            &lt;!--使用的插件列表 。 --&gt;
            &lt;plugins&gt;
                &lt;!--plugin元素包含描述插件所需要的信息。 --&gt;
                &lt;plugin&gt;
                    &lt;!--插件在仓库里的group ID --&gt;
                    &lt;groupId /&gt;
                    &lt;!--插件在仓库里的artifact ID --&gt;
                    &lt;artifactId /&gt;
                    &lt;!--被使用的插件的版本（或版本范围） --&gt;
                    &lt;version /&gt;
                    &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;
                    &lt;extensions /&gt;
                    &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;
                    &lt;executions&gt;
                        &lt;!--execution元素包含了插件执行需要的信息 --&gt;
                        &lt;execution&gt;
                            &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;
                            &lt;id /&gt;
                            &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;
                            &lt;phase /&gt;
                            &lt;!--配置的执行目标 --&gt;
                            &lt;goals /&gt;
                            &lt;!--配置是否被传播到子POM --&gt;
                            &lt;inherited /&gt;
                            &lt;!--作为DOM对象的配置 --&gt;
                            &lt;configuration /&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                    &lt;!--项目引入插件所需要的额外依赖 --&gt;
                    &lt;dependencies&gt;
                        &lt;!--参见dependencies/dependency元素 --&gt;
                        &lt;dependency&gt;
                            ......
                        &lt;/dependency&gt;
                    &lt;/dependencies&gt;
                    &lt;!--任何配置是否被传播到子项目 --&gt;
                    &lt;inherited /&gt;
                    &lt;!--作为DOM对象的配置 --&gt;
                    &lt;configuration /&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
        &lt;!--使用的插件列表 --&gt;
        &lt;plugins&gt;
            &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
            &lt;plugin&gt;
                &lt;groupId /&gt;
                &lt;artifactId /&gt;
                &lt;version /&gt;
                &lt;extensions /&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id /&gt;
                        &lt;phase /&gt;
                        &lt;goals /&gt;
                        &lt;inherited /&gt;
                        &lt;configuration /&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;dependencies&gt;
                    &lt;!--参见dependencies/dependency元素 --&gt;
                    &lt;dependency&gt;
                        ......
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
                &lt;goals /&gt;
                &lt;inherited /&gt;
                &lt;configuration /&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;
    &lt;profiles&gt;
        &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;
        &lt;profile&gt;
            &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;
            &lt;id /&gt;
            &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;
            &lt;activation&gt;
                &lt;!--profile默认是否激活的标志 --&gt;
                &lt;activeByDefault /&gt;
                &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;
                &lt;jdk /&gt;
                &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;
                &lt;os&gt;
                    &lt;!--激活profile的操作系统的名字 --&gt;
                    &lt;name&gt;Windows XP&lt;/name&gt;
                    &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;
                    &lt;family&gt;Windows&lt;/family&gt;
                    &lt;!--激活profile的操作系统体系结构 --&gt;
                    &lt;arch&gt;x86&lt;/arch&gt;
                    &lt;!--激活profile的操作系统版本 --&gt;
                    &lt;version&gt;5.1.2600&lt;/version&gt;
                &lt;/os&gt;
                &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;
                &lt;property&gt;
                    &lt;!--激活profile的属性的名称 --&gt;
                    &lt;name&gt;mavenVersion&lt;/name&gt;
                    &lt;!--激活profile的属性的值 --&gt;
                    &lt;value&gt;2.0.3&lt;/value&gt;
                &lt;/property&gt;
                &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;
                &lt;file&gt;
                    &lt;!--如果指定的文件存在，则激活profile。 --&gt;
                    &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    &lt;/exists&gt;
                    &lt;!--如果指定的文件不存在，则激活profile。 --&gt;
                    &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    &lt;/missing&gt;
                &lt;/file&gt;
            &lt;/activation&gt;
            &lt;!--构建项目所需要的信息。参见build元素 --&gt;
            &lt;build&gt;
                &lt;defaultGoal /&gt;
                &lt;resources&gt;
                    &lt;resource&gt;
                        &lt;targetPath /&gt;
                        &lt;filtering /&gt;
                        &lt;directory /&gt;
                        &lt;includes /&gt;
                        &lt;excludes /&gt;
                    &lt;/resource&gt;
                &lt;/resources&gt;
                &lt;testResources&gt;
                    &lt;testResource&gt;
                        &lt;targetPath /&gt;
                        &lt;filtering /&gt;
                        &lt;directory /&gt;
                        &lt;includes /&gt;
                        &lt;excludes /&gt;
                    &lt;/testResource&gt;
                &lt;/testResources&gt;
                &lt;directory /&gt;
                &lt;finalName /&gt;
                &lt;filters /&gt;
                &lt;pluginManagement&gt;
                    &lt;plugins&gt;
                        &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
                        &lt;plugin&gt;
                            &lt;groupId /&gt;
                            &lt;artifactId /&gt;
                            &lt;version /&gt;
                            &lt;extensions /&gt;
                            &lt;executions&gt;
                                &lt;execution&gt;
                                    &lt;id /&gt;
                                    &lt;phase /&gt;
                                    &lt;goals /&gt;
                                    &lt;inherited /&gt;
                                    &lt;configuration /&gt;
                                &lt;/execution&gt;
                            &lt;/executions&gt;
                            &lt;dependencies&gt;
                                &lt;!--参见dependencies/dependency元素 --&gt;
                                &lt;dependency&gt;
                                    ......
                                &lt;/dependency&gt;
                            &lt;/dependencies&gt;
                            &lt;goals /&gt;
                            &lt;inherited /&gt;
                            &lt;configuration /&gt;
                        &lt;/plugin&gt;
                    &lt;/plugins&gt;
                &lt;/pluginManagement&gt;
                &lt;plugins&gt;
                    &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
                    &lt;plugin&gt;
                        &lt;groupId /&gt;
                        &lt;artifactId /&gt;
                        &lt;version /&gt;
                        &lt;extensions /&gt;
                        &lt;executions&gt;
                            &lt;execution&gt;
                                &lt;id /&gt;
                                &lt;phase /&gt;
                                &lt;goals /&gt;
                                &lt;inherited /&gt;
                                &lt;configuration /&gt;
                            &lt;/execution&gt;
                        &lt;/executions&gt;
                        &lt;dependencies&gt;
                            &lt;!--参见dependencies/dependency元素 --&gt;
                            &lt;dependency&gt;
                                ......
                            &lt;/dependency&gt;
                        &lt;/dependencies&gt;
                        &lt;goals /&gt;
                        &lt;inherited /&gt;
                        &lt;configuration /&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/build&gt;
            &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;
            &lt;modules /&gt;
            &lt;!--发现依赖和扩展的远程仓库列表。 --&gt;
            &lt;repositories&gt;
                &lt;!--参见repositories/repository元素 --&gt;
                &lt;repository&gt;
                    &lt;releases&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/snapshots&gt;
                    &lt;id /&gt;
                    &lt;name /&gt;
                    &lt;url /&gt;
                    &lt;layout /&gt;
                &lt;/repository&gt;
            &lt;/repositories&gt;
            &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;
            &lt;pluginRepositories&gt;
                &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;
                &lt;pluginRepository&gt;
                    &lt;releases&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/snapshots&gt;
                    &lt;id /&gt;
                    &lt;name /&gt;
                    &lt;url /&gt;
                    &lt;layout /&gt;
                &lt;/pluginRepository&gt;
            &lt;/pluginRepositories&gt;
            &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;
            &lt;dependencies&gt;
                &lt;!--参见dependencies/dependency元素 --&gt;
                &lt;dependency&gt;
                    ......
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
            &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;
            &lt;reports /&gt;
            &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;
            &lt;reporting&gt;
                ......
            &lt;/reporting&gt;
            &lt;!--参见dependencyManagement元素 --&gt;
            &lt;dependencyManagement&gt;
                &lt;dependencies&gt;
                    &lt;!--参见dependencies/dependency元素 --&gt;
                    &lt;dependency&gt;
                        ......
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
            &lt;/dependencyManagement&gt;
            &lt;!--参见distributionManagement元素 --&gt;
            &lt;distributionManagement&gt;
                ......
            &lt;/distributionManagement&gt;
            &lt;!--参见properties元素 --&gt;
            &lt;properties /&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
    &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;
    &lt;modules /&gt;
    &lt;!--发现依赖和扩展的远程仓库列表。 --&gt;
    &lt;repositories&gt;
        &lt;!--包含需要连接到远程仓库的信息 --&gt;
        &lt;repository&gt;
            &lt;!--如何处理远程仓库里发布版本的下载 --&gt;
            &lt;releases&gt;
                &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;
                &lt;enabled /&gt;
                &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;
                &lt;updatePolicy /&gt;
                &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;
                &lt;checksumPolicy /&gt;
            &lt;/releases&gt;
            &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 
                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;
            &lt;snapshots&gt;
                &lt;enabled /&gt;
                &lt;updatePolicy /&gt;
                &lt;checksumPolicy /&gt;
            &lt;/snapshots&gt;
            &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;
            &lt;id&gt;banseon-repository-proxy&lt;/id&gt;
            &lt;!--远程仓库名称 --&gt;
            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;
            &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;
            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;
            &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 
                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;
            &lt;layout&gt;default&lt;/layout&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;
    &lt;pluginRepositories&gt;
        &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;
        &lt;pluginRepository&gt;
            ......
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;
 
 
    &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;!--依赖的group ID --&gt;
            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
            &lt;!--依赖的artifact ID --&gt;
            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;
            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;
            &lt;version&gt;3.8.1&lt;/version&gt;
            &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 
                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;
            &lt;type&gt;jar&lt;/type&gt;
            &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 
                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;
            &lt;classifier&gt;&lt;/classifier&gt;
            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 
                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --&gt;
            &lt;systemPath&gt;&lt;/systemPath&gt;
            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;
    &lt;reports&gt;&lt;/reports&gt;
    &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;
    &lt;reporting&gt;
        &lt;!--true，则，网站不包括默认的报表。这包括&quot;项目信息&quot;菜单中的报表。 --&gt;
        &lt;excludeDefaults /&gt;
        &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --&gt;
        &lt;outputDirectory /&gt;
        &lt;!--使用的报表插件和他们的配置。 --&gt;
        &lt;plugins&gt;
            &lt;!--plugin元素包含描述报表插件需要的信息 --&gt;
            &lt;plugin&gt;
                &lt;!--报表插件在仓库里的group ID --&gt;
                &lt;groupId /&gt;
                &lt;!--报表插件在仓库里的artifact ID --&gt;
                &lt;artifactId /&gt;
                &lt;!--被使用的报表插件的版本（或版本范围） --&gt;
                &lt;version /&gt;
                &lt;!--任何配置是否被传播到子项目 --&gt;
                &lt;inherited /&gt;
                &lt;!--报表插件的配置 --&gt;
                &lt;configuration /&gt;
                &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;
                &lt;reportSets&gt;
                    &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;
                    &lt;reportSet&gt;
                        &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;
                        &lt;id /&gt;
                        &lt;!--产生报表集合时，被使用的报表的配置 --&gt;
                        &lt;configuration /&gt;
                        &lt;!--配置是否被继承到子POMs --&gt;
                        &lt;inherited /&gt;
                        &lt;!--这个集合里使用到哪些报表 --&gt;
                        &lt;reports /&gt;
                    &lt;/reportSet&gt;
                &lt;/reportSets&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/reporting&gt;
    &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact 
        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--参见dependencies/dependency元素 --&gt;
            &lt;dependency&gt;
                ......
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;
    &lt;distributionManagement&gt;
        &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;
        &lt;repository&gt;
            &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;
            &lt;uniqueVersion /&gt;
            &lt;id&gt;banseon-maven2&lt;/id&gt;
            &lt;name&gt;banseon maven2&lt;/name&gt;
            &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt;
            &lt;layout /&gt;
        &lt;/repository&gt;
        &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;
        &lt;snapshotRepository&gt;
            &lt;uniqueVersion /&gt;
            &lt;id&gt;banseon-maven2&lt;/id&gt;
            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;
            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;
            &lt;layout /&gt;
        &lt;/snapshotRepository&gt;
        &lt;!--部署项目的网站需要的信息 --&gt;
        &lt;site&gt;
            &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;
            &lt;id&gt;banseon-site&lt;/id&gt;
            &lt;!--部署位置的名称 --&gt;
            &lt;name&gt;business api website&lt;/name&gt;
            &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;
            &lt;url&gt;
                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
            &lt;/url&gt;
        &lt;/site&gt;
        &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;
        &lt;downloadUrl /&gt;
        &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;
        &lt;relocation&gt;
            &lt;!--构件新的group ID --&gt;
            &lt;groupId /&gt;
            &lt;!--构件新的artifact ID --&gt;
            &lt;artifactId /&gt;
            &lt;!--构件新的版本号 --&gt;
            &lt;version /&gt;
            &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;
            &lt;message /&gt;
        &lt;/relocation&gt;
        &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 
            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;
        &lt;status /&gt;
    &lt;/distributionManagement&gt;
    &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;
    &lt;properties /&gt;
&lt;/project&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maven环境配置]]></title>
        <id>https://dingdingtao.github.io/post/maven-huan-jing-pei-zhi/</id>
        <link href="https://dingdingtao.github.io/post/maven-huan-jing-pei-zhi/">
        </link>
        <updated>2021-03-03T06:31:13.000Z</updated>
        <summary type="html"><![CDATA[<center>
maven安装和环境变量配置
</center>
]]></summary>
        <content type="html"><![CDATA[<center>
maven安装和环境变量配置
</center>
<!-- more -->
<h2 id="系统要求">系统要求</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK</td>
<td>Maven 3.3 要求 JDK 1.7 或以上</br>Maven 3.2 要求 JDK 1.6 或以上 </br>Maven 3.0/3.1 要求 JDK 1.5 或以上</td>
</tr>
<tr>
<td>内存</td>
<td>没有最低要求</td>
</tr>
<tr>
<td>磁盘</td>
<td>Maven 自身安装需要大约 10 MB 空间。除此之外，额外的磁盘空间将用于你的本地 Maven 仓库。你本地仓库的大小取决于使用情况，但预期至少 500 MB</td>
</tr>
<tr>
<td>操作系统</td>
<td>没有最低要求</td>
</tr>
</tbody>
</table>
<h2 id="maven-下载">Maven 下载</h2>
<p>Maven 下载地址：<a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></p>
<h2 id="maven-环境变量">Maven 环境变量</h2>
<ol>
<li>添加环境变量 MAVEN_HOME</li>
<li>变量值为Maven解压目录</li>
<li>编辑Path系统变量</li>
<li>添加变量值：<code>;%MAVEN_HOME%\bin</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pandas数据处理]]></title>
        <id>https://dingdingtao.github.io/post/pandas-shu-ju-chu-li/</id>
        <link href="https://dingdingtao.github.io/post/pandas-shu-ju-chu-li/">
        </link>
        <updated>2021-03-02T06:49:19.000Z</updated>
        <summary type="html"><![CDATA[<center>
pandas模块的简单使用、常用函数、数据处理等
</center>
]]></summary>
        <content type="html"><![CDATA[<center>
pandas模块的简单使用、常用函数、数据处理等
</center>
<!-- more -->
<h2 id="介绍">介绍</h2>
<p>在Python中，pandas是基于NumPy数组构建的，使数据预处理、清洗、分析工作变得更快更简单。pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。<br>
使用下面格式约定，引入pandas包：</p>
<pre><code class="language-python">import pandas as pd
</code></pre>
<p><strong>pandas有两个主要数据结构：Series和DataFrame。</strong></p>
<h2 id="series">Series</h2>
<p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成，即index和values两部分，可以通过索引的方式选取Series中的单个或一组值。</p>
<h2 id="dataframe">DataFrame</h2>
<p>DataFrame是一个表格型的数据类型，每列值类型可以不同，是最常用的pandas对象。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p>
<h3 id="dataframe的创建">DataFrame的创建</h3>
<p>pd.DataFrame(data,columns = [ ],index = [ ])：columns和index为指定的列、行索引，并按照顺序排列。</p>
<ul>
<li>创建DataFrame最常用的是直接传入一个由等长列表或NumPy数组组成的<strong>字典</strong>，会自动加上行索引，字典的<strong>键</strong>会被当做列 <strong>索引</strong>：</li>
</ul>
<pre><code class="language-python">import pandas as pd
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
df= pd.DataFrame(data)
In [45]: df
Out[45]: 
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002
5  3.2  Nevada  2003
</code></pre>
<p>如果创建时指定了columns和index索引，则按照索引顺序排列，并且如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<pre><code class="language-python">In [48]: df2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
   ....:                       index=['one', 'two', 'three', 'four', 'five', 'six'])
In [49]: df2
Out[49]: 
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN
</code></pre>
<p>另一种常见的创建DataFrame方式是使用嵌套字典，如果嵌套字典传给DataFrame，pandas就会被解释为外层字典的键作为列，内层字典键则作为行索引：</p>
<pre><code class="language-python">In [65]: pop = {'Nevada': {2001: 2.4, 2002: 2.9},
....:        'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}
In [66]: df3 = pd.DataFrame(pop)
In [67]: df3
Out[67]: 
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6
</code></pre>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>二维ndarray</td>
<td>数据矩阵，还可以传入行标和列标</td>
</tr>
<tr>
<td>由数组、列表或元组组成的字典</td>
<td>每个序列会变成DataFrame的一列。所有序列的长度必须相同</td>
</tr>
<tr>
<td>NumPy的结构化/记录数组</td>
<td>类似于“由数组组成的字典”</td>
</tr>
<tr>
<td>由Series组成的字典</td>
<td>每个Series会成为一列。如果没有显式指定索引，则各Series的索引会被合并成结果的行索引</td>
</tr>
<tr>
<td>由字典组成的字典</td>
<td>各内层字典会成为一列。键会被合并成结果的行索引，跟“由Series组成的字典”的情况一样</td>
</tr>
<tr>
<td>字典或Series的列表</td>
<td>各项将会成为DataFrame的一行。字典键或Series索引的并集将会成为DataFrame的列标</td>
</tr>
<tr>
<td>由列表或元组组成的列表</td>
<td>类似于“二维ndarray”</td>
</tr>
<tr>
<td>另一个DataFrame</td>
<td>该DataFrame的索引将会被沿用，除非显式指定了其他索引</td>
</tr>
<tr>
<td>NumPy的MaskedArray</td>
<td>类似于“二维ndarray”的情况，只是掩码值在结果DataFrame会变成NA/缺失值</td>
</tr>
</tbody>
</table>
<h3 id="dataframe对象操作">DataFrame对象操作</h3>
<ul>
<li>df.values：将DataFrame转换为ndarray二维数组，注意后面不加()。</li>
<li>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。</li>
<li>列可以通过赋值的方式进行修改。例如，我们可以给那个空的&quot;debt&quot;列赋上一个标量值或一组值。</li>
<li>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值。</li>
<li>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</li>
</ul>
<pre><code class="language-python">import pandas as pd
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
In [48]: df2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
   ....:                       index=['one', 'two', 'three', 'four', 'five', 'six'])

In [50]: df2.columns
Out[50]: Index(['year', 'state', 'pop', 'debt'], dtype='object')
#通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。
In [51]: df2['state']  #或者df2.state
Out[51]: 
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
#列可以通过赋值的方式进行修改。例如，我们可以给那个空的&quot;debt&quot;列赋上一个标量值或一组值
In [54]: frame2['debt'] = 16.5
In [55]: frame2
Out[55]: 
       year   state  pop  debt
one    2000    Ohio  1.5  16.5
two    2001    Ohio  1.7  16.5
three  2002    Ohio  3.6  16.5
four   2001  Nevada  2.4  16.5
five   2002  Nevada  2.9  16.5
six    2003  Nevada  3.2  16.5
#将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值
In [58]: val = pd.Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
In [59]: df2['debt'] = val
In [60]: df2
Out[60]: 
       year   state  pop  debt
one    2000    Ohio  1.5   16.5
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   16.5
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7
six    2003  Nevada  3.2   16.5
#为不存在的列赋值，会创建出一个新列
In [61]: df2['eastern'] = df2.state == 'Ohio'
In [62]: df2
Out[62]: 
       year   state  pop  debt  eastern
one    2000    Ohio  1.5   NaN     True
two    2001    Ohio  1.7  -1.2     True
three  2002    Ohio  3.6   NaN     True
four   2001  Nevada  2.4  -1.5    False
five   2002  Nevada  2.9  -1.7    False
six    2003  Nevada  3.2   NaN    False
#关键字del用于删除列
In [63]: del df2['eastern']
In [64]: df2.columns
Out[64]: Index(['year', 'state', 'pop', 'debt'], dtype='object')
</code></pre>
<h2 id="pandas的基本功能">pandas的基本功能</h2>
<p><strong>数据索引</strong>:Series和DataFrame的索引是Index类型，Index对象是不可修改，可通过索引值或索引标签获取目标数据，也可通过索引使序列或数据框的计算、操作实现自动化对齐。索引类型index的常用方法：</p>
<ul>
<li>.append(idx)：连接另一个Index对象，产生新的Index对象</li>
<li>.diff(idx)：计算差集，产生新的Index对象</li>
<li>.intersection(idx)：计算交集</li>
<li>.union(idx)：计算并集</li>
<li>.delete(loc)：删除loc位置处的元素</li>
<li>.insert(loc,e)：在loc位置增加一个元素<br>
<strong>重新索引</strong>:能够改变、重排Series和DataFrame索引，会创建一个新对象，如果某个索引值当前不存在，就引入缺失值。<br>
<strong>df.reindex(index, columns ,fill_value, method, limit, copy )</strong>:index/columns为新的行列自定义索引；fill_value为用于填充缺失位置的值；method为填充方法，ffill当前值向前填充，bfill向后填充；limit为最大填充量；copy 默认True，生成新的对象，False时，新旧相等不复制。</li>
</ul>
<pre><code class="language-python">In [98]: frame = pd.DataFrame(np.arange(9).reshape((3, 3)),
   ....:                      index=['a', 'c', 'd'],columns=['Ohio', 'Texas', 'California'])
In [99]: frame
Out[99]: 
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8

In [100]: frame2 = frame.reindex(['a', 'b', 'c', 'd'])
In [101]: frame2
Out[101]: 
   Ohio  Texas  California
a   0.0    1.0         2.0
b   NaN    NaN         NaN
c   3.0    4.0         5.0
d   6.0    7.0         8.0
</code></pre>
<p><strong>删除指定索引</strong>:默认返回的是一个新对象。<br>
<strong>.drop()</strong>:能够删除Series和DataFrame指定行或列索引。<br>
删除一行或者一列时，用单引号指定索引，删除多行时用列表指定索引。<br>
如果删除的是列索引，需要增加axis=1或axis='columns'作为参数。<br>
增加inplace=True作为参数，可以就地修改对象，不会返回新的对象。<br>
<strong>索引、选取和过滤</strong><br>
<strong>df.loc[行标签，列标签]</strong>:通过标签查询指定的数据，第一个值为行标签，第二值为列标签。当第二个参数为空时，查询的是单个或多个行的所有列。如果查询多个行、列的话，则两个参数用列表表示。<br>
<strong>df.iloc[行位置，列位置]</strong>:通过默认生成的数字索引查询指定的数据。</p>
<pre><code class="language-python">In [128]: data = pd.DataFrame(np.arange(16).reshape((4, 4)),
   .....:                     index=['Ohio', 'Colorado', 'Utah', 'New York'],
   .....:                     columns=['one', 'two', 'three', 'four'])
​
In [129]: data
Out[129]: 
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
#df.loc选取第二行、第二三列
In [137]: data.loc['Colorado', ['two', 'three']]   
Out[137]: 
two      5
three    6
Name: Colorado, dtype: int64
#df.iloc选取第二行、第二三列
In [138]: data.iloc[1, [1, 2]]
Out[138]: 
two      5
three    6
Name: Colorado, dtype: int64
</code></pre>
<p>在pandas中，有多个方法可以选取和重新组合数据:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>df[val]</td>
<td>从DataFrame选取单列或一组列；在特殊情况下比较便利：布尔型数组（过滤行）、切片（行切片）、布尔型DataFrame（根据条件设置值）</td>
</tr>
<tr>
<td>df.loc[val]</td>
<td>通过标签，选取DataFrame的单个行或一组行</td>
</tr>
<tr>
<td>df.loc[:, val]</td>
<td>通过标签，选取单列或列子集</td>
</tr>
<tr>
<td>df.loc[val1, val2]</td>
<td>通过标签，同时选取行和列</td>
</tr>
<tr>
<td>df.iloc[where]</td>
<td>通过整数位置，从DataFrame选取单个行或行子集</td>
</tr>
<tr>
<td>df.iloc[:, where]</td>
<td>通过整数位置，从DataFrame选取单个列或列子集</td>
</tr>
<tr>
<td>df.iloc[where_i, where_j]</td>
<td>通过整数位置，同时选取行和列</td>
</tr>
<tr>
<td>df.at[label_i, label_j]</td>
<td>通过行和列标签，选取单一的标量</td>
</tr>
<tr>
<td>df.iat[i, j]</td>
<td>通过行和列的位置，选取单一的标量</td>
</tr>
<tr>
<td>reindex</td>
<td>通过标签选取行或列</td>
</tr>
<tr>
<td>get_value, set_value</td>
<td>通过行和列标签选取单一值</td>
</tr>
</tbody>
</table>
<p><strong>算术运算</strong>:算术运算根据行列索引，对齐后运算，运算默认产生浮点数，对齐时缺项填充NaN (空值)。除了用+-*/外，还可以用Series和DataFrame的算术方法，这些方法传入fill_value参数时，可以填充缺省值。比如df1.add(df2, fill_value = 1)。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>add, radd</td>
<td>用于加法（+）</td>
</tr>
<tr>
<td>sub, rsub</td>
<td>用于减法（-）</td>
</tr>
<tr>
<td>div, rdiv</td>
<td>用于除法（/）</td>
</tr>
<tr>
<td>floordiv, rfloordiv</td>
<td>用于底除（//）</td>
</tr>
<tr>
<td>mul, rmul</td>
<td>用于乘法（*）</td>
</tr>
<tr>
<td>pow, rpow</td>
<td>用于指数（**）</td>
</tr>
</tbody>
</table>
<p>比较运算只能比较相同索引的元素，不进行补齐。采用&gt;&lt; &gt;= &lt;= == !=等符号进行的比较运算，产生布尔值。<br>
<strong>排序</strong> ：在排序时，任何缺失值默认都会被放到末尾<br>
<strong>.sort_index(axis=0, ascending=True)</strong>：根据指定轴索引的值进行排序。默认轴axis=0, ascending=True，即默认根据0轴的索引值做升序排序。轴axis=1为根据1轴的索引值排序， ascending=False为降序。<br>
在指定轴上根据数值进行排序，默认升序。<br>
<strong>Series.sort_values(axis=0, ascending=True)</strong>：只能根据0轴的值排序。<br>
<strong>DataFrame.sort_values(by, axis=0, ascending=True)</strong>，参数by为axis轴上的某个索引或索引列表。</p>
<h2 id="pandas数据分析">pandas数据分析</h2>
<h3 id="统计分析-相关分析">统计分析、相关分析</h3>
<p><strong>适用于Series和DataFrame的基本统计分析函数</strong>：传入axis='columns'或axis=1将会按行进行运算。<br>
<strong>.describe()</strong>：针对各列的多个统计汇总，用统计学指标快速描述数据的概要。<br>
<strong>.sum()</strong>：计算各列数据的和<br>
<strong>.count()</strong>：非NaN值的数量<br>
<strong>.mean( )/.median()</strong>：计算数据的算术平均值、算术中位数<br>
<strong>.var()/.std()</strong>：计算数据的方差、标准差<br>
<strong>.corr()/.cov()</strong>：计算相关系数矩阵、协方差矩阵，是通过参数对计算出来的。Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵。<br>
<strong>.corrwith()</strong>：利用DataFrame的corrwith方法，可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算），传入一个DataFrame则会计算按列名配对的相关系数。<br>
<strong>.min()/.max()</strong>：计算数据的最小值、最大值<br>
<strong>.diff()</strong>：计算一阶差分，对时间序列很有效<br>
<strong>.mode()</strong>：计算众数，返回频数最高的那（几）个<br>
<strong>.mean()</strong>：计算均值<br>
<strong>.quantile()</strong>：计算分位数（0到1）<br>
<strong>.isin()</strong>：用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集<br>
适用于Series的基本统计分析函数，DataFrame[列名]返回的是一个Series类型。<br>
<strong>.unique()</strong>：返回一个Series中的唯一值组成的数组。<br>
<strong>.value_counts()</strong>：计算一个Series中各值出现的频率。<br>
<strong>.argmin()/.argmax()</strong>：计算数据最大值、最小值所在位置的索引位置（自动索引）<br>
<strong>.idxmin()/.idxmax()</strong>：计算数据最大值、最小值所在位置的索引（自定义索引）</p>
<h2 id="分组">分组</h2>
<ul>
<li><strong>DataFrame.groupby()</strong>：分组函数，使用方法参考<br>
<a href="https://blog.csdn.net/cymy001/article/details/78300900">Python3pandas库DataFrame的分组,拼接,统计运算等用法(基础整理)</a></li>
<li><strong>pandas.cut()</strong>：根据数据分析对象的特征，按照一定的数值指标，把数据分析对象划分为不同的区间部分来进行研究，以揭示其内在的联系和规律性。类似给成绩设定优良中差，比如：0-59分为差，60-70分为中，71-80分为优秀等等。使用方法参考<br>
<a href="https://blog.csdn.net/weixin_39541558/article/details/80578529">pandas.cut与pandas.qcut使用方法与区别</a><br>
<a href="https://blog.csdn.net/missyougoon/article/details/83986511">pandas中pd.cut()的功能和作用</a></li>
</ul>
<h2 id="pandas读写文本格式的数据">pandas读写文本格式的数据</h2>
<p>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。下表对它们进行了总结，其中read_csv()、read_table()、to_csv()是用得最多的。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>read_csv</td>
<td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td>
</tr>
<tr>
<td>read_table</td>
<td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（'\t'）</td>
</tr>
<tr>
<td>read_fwf</td>
<td>读取定宽列格式数据（也就是说，没有分隔符）</td>
</tr>
<tr>
<td>read_clipboard</td>
<td>读取剪贴板中的数据，可以看作read_table的剪贴板版本。在将网页转换为表格时很有用</td>
</tr>
<tr>
<td>read_excel</td>
<td>从Excel XLS 或 XLSX 文件读取表格数据</td>
</tr>
<tr>
<td>read_hdf</td>
<td>读取pandas写的HDFS文件</td>
</tr>
<tr>
<td>read_html</td>
<td>读取HTML文档中的所有表格</td>
</tr>
<tr>
<td>read_json</td>
<td>读取JSON字符串中的数据</td>
</tr>
<tr>
<td>read_msgpack</td>
<td>二进制格式编码的pandas数据</td>
</tr>
<tr>
<td>read_pickle</td>
<td>读取Python pickle格式中存储的任意对象</td>
</tr>
<tr>
<td>read_sas</td>
<td>读取存储于SAS系统自定义存储格式的SAS数据集</td>
</tr>
<tr>
<td>read_sql</td>
<td>（使用SQLAlchemy）读取SQL查询结果为pandas的DataFrame</td>
</tr>
<tr>
<td>read_stata</td>
<td>读取Stata文件格式的数据集</td>
</tr>
<tr>
<td>read_feather</td>
<td>读取Feather二进制文件格式</td>
</tr>
</tbody>
</table>
<p>工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的参数非常多（read_csv有超过50个参数）。具体使用参考<a href="https://seancheney.gitbook.io/python-for-data-analysis-2nd/di-06-zhang-shu-ju-jia-zai-cun-chu-yu-wen-jian-ge-shi">数据加载、存储与文件格式</a></p>
<h2 id="用pandas来进行数据清洗和准备">用pandas来进行数据清洗和准备</h2>
<p>在数据分析和建模的过程中，相当多的时间要用在数据准备上：加载、清理、转换以及重塑。</p>
<h3 id="处理缺失数据">处理缺失数据</h3>
<p>在许多数据分析工作中，缺失数据是经常发生的。对于数值数据，pandas使用浮点值NaN（np.nan）表示缺失数据，也可将缺失值表示为NA（Python内置的None值）。</p>
<ul>
<li><strong>.info()</strong>：查看数据的信息，包括每个字段的名称、非空数量、字段的数据类型。</li>
<li><strong>.isnull()</strong>：返回一个同样长度的值为布尔型的对象（Series或DataFrame），表示哪些值是缺失的，**.notnull()**为其否定形式。</li>
</ul>
<pre><code class="language-python">import pandas as pd
import numpy as np
In [10]: string_data = pd.Series(['aardvark', 'artichoke', np.nan, None])
In [11]: string_data
Out[11]:
0     aardvark
1    artichoke
2          NaN
3         None
dtype: object

In [14]: string_data.isnull()
Out[14]: 
0    False
1    False
2     True
3     True
dtype: bool
</code></pre>
<ul>
<li><strong>.dropna()</strong>：删除缺失数据。对于Series对象，dropna返回一个仅含非空数据和索引值的Series。对于DataFrame对象，dropna默认删除<strong>含有</strong>缺失值的行；如果想删除<strong>含有</strong>缺失值的列，需传入axis = 1作为参数；如果想删除<strong>全部</strong>为缺失值的行或者列，需传入how='all'作为参数；如果想留下一部分缺失数据，需传入thresh = n作为参数，表示每行至少n个非NA值。</li>
</ul>
<pre><code class="language-python">import pandas as pd
import numpy as np
In [19]: data = pd.DataFrame([[1., 6.5, 3.], [1., NA, NA], [NA, NA, NA], [NA, 6.5, 3.]])
In [20]: data.dropna()
Out[22]: 
     0    1    2
0  1.0  6.5  3.0
#传入how='all'将只丢弃全为NA的那些行：
In [23]: data.dropna(how='all')
Out[23]: 
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
3  NaN  6.5  3.0

In [24]: data[4] = NA
In [25]: data
Out[25]: 
     0    1    2   4
0  1.0  6.5  3.0 NaN
1  1.0  NaN  NaN NaN
2  NaN  NaN  NaN NaN
3  NaN  6.5  3.0 NaN
#用这种方式丢弃列，只需传入axis=1即可：
In [26]: data.dropna(axis=1, how='all')
Out[26]: 
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
2  NaN  NaN  NaN
3  NaN  6.5  3.0
#假设你只想留下一部分观测数据，可以用thresh参数实现此目的：
In [27]: df = pd.DataFrame(np.random.randn(7, 3))
In [28]: df.iloc[:4, 1] = NA
In [29]: df.iloc[:2, 2] = NA
In [30]: df
Out[30]: 
          0         1         2
0 -0.204708       NaN       NaN
1 -0.555730       NaN       NaN
2  0.092908       NaN  0.769023
3  1.246435       NaN -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741

In [32]: df.dropna(thresh=2)
Out[32]: 
          0         1         2
2  0.092908       NaN  0.769023
3  1.246435       NaN -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
</code></pre>
<ul>
<li><strong>.fillna(value,method,limit,inplace)</strong>：填充缺失值。value为用于填充的值（比如0、'a'等）或者是字典（比如{'列':1,'列':8,……}为指定列的缺失数据填充值）；method默认值为ffill，向前填充，bfill为向后填充；limit为向前或者向后填充的最大填充量。inplace默认会返回新对象，修改为inplace=True可以对现有对象进行就地修改。</li>
</ul>
<h3 id="数据转换">数据转换</h3>
<h4 id="替换值">替换值</h4>
<p><strong>.replace(old, new)</strong>：用新的数据替换老的数据，如果希望一次性替换多个值，old和new可以是列表。默认会返回一个新的对象，传入inplace=True可以对现有对象进行就地修改。</p>
<h4 id="删除重复数据">删除重复数据</h4>
<ul>
<li><strong>.duplicated()</strong>：判断各行是否是重复行（前面出现过的行），返回一个布尔型Series。</li>
<li><strong>.drop_duplicates()</strong>：删除重复行，返回删除后的DataFrame对象。默认保留的是第一个出现的行，传入keep='last'作为参数后，则保留最后一个出现的行。</li>
<li>两者都默认会对全部列做判断，在传入列索引组成的列表[ '列1' , '列2' , ……]作为参数后，可以只对这些列进行重复项判断。</li>
</ul>
<h4 id="利用函数或字典进行数据转换">利用函数或字典进行数据转换</h4>
<p><strong>Series.map()</strong>：接受一个函数或字典作为参数。使用map方法是一种实现元素级转换以及其他数据清理工作的便捷方式。</p>
<pre><code class="language-python">import pandas as pd
In [52]: data = pd.DataFrame({'food': ['bacon', 'pulled pork', 'bacon','pastrami', 'corned beef', 'bacon','pastrami', 'honey ham', 'nova lox'],
   ....                       'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]})
meat_to_animal = {
  'bacon': 'pig',  'pulled pork': 'pig',  'pastrami': 'cow',  'corned beef': 'cow',
  'honey ham': 'pig',  'nova lox': 'salmon'
}
#增加一列animal
In [57]: data['animal'] = data['food'].map(meat_to_animal)
In [58]: data
Out[58]: 
          food  ounces  animal
0        bacon     4.0     pig
1  pulled pork     3.0     pig
2        bacon    12.0     pig
3     Pastrami     6.0     cow
4  corned beef     7.5     cow
5        Bacon     8.0     pig
6     pastrami     3.0     cow
7    honey ham     5.0     pig
8     nova lox     6.0  salmon
</code></pre>
<h3 id="dataframe常见函数">DataFrame常见函数</h3>
<p>df.head()：查询数据的前五行<br>
df.tail()：查询数据的末尾5行<br>
pandas.cut()<br>
pandas.qcut() 基于分位数的离散化函数。基于秩或基于样本分位数将变量离散化为等大小桶。<br>
pandas.date_range() 返回一个时间索引<br>
df.apply() 沿相应轴应用函数<br>
Series.value_counts() 返回不同数据的计数值<br>
df.aggregate()<br>
df.reset_index() 重新设置index，参数drop = True时会丢弃原来的索引，设置新的从0开始的索引。常与groupby()一起用<br>
numpy.zeros()</p>
<h2 id="参考">参考</h2>
<p>转自<a href="https://www.jianshu.com/p/840ba135df30">Python pandas用法</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pymysql数据库连接]]></title>
        <id>https://dingdingtao.github.io/post/pymysql-shu-ju-ku-lian-jie/</id>
        <link href="https://dingdingtao.github.io/post/pymysql-shu-ju-ku-lian-jie/">
        </link>
        <updated>2021-03-02T06:35:56.000Z</updated>
        <summary type="html"><![CDATA[<center>
Python pymsql模块简单使用方法
</center>
]]></summary>
        <content type="html"><![CDATA[<center>
Python pymsql模块简单使用方法
</center>
<!-- more -->
<h2 id="安装">安装</h2>
<pre><code class="language-text">pip install pymysql
</code></pre>
<h2 id="使用">使用</h2>
<h3 id="执行sql">执行sql</h3>
<pre><code class="language-python">#!/usr/bin/env pytho
# -*- coding:utf-8 -*-
import pymysql
  
# 创建连接
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1', charset='utf8')
# 创建游标
cursor = conn.cursor()
# 执行SQL，并返回收影响行数
effect_row = cursor.execute(&quot;select * from tb7&quot;)
# 执行SQL，并返回受影响行数
#effect_row = cursor.execute(&quot;update tb7 set pass = '123' where nid = %s&quot;, (11,))
# 执行SQL，并返回受影响行数,执行多次
#effect_row = cursor.executemany(&quot;insert into tb7(user,pass,licnese)values(%s,%s,%s)&quot;, [(&quot;u1&quot;,&quot;u1pass&quot;,&quot;11111&quot;),(&quot;u2&quot;,&quot;u2pass&quot;,&quot;22222&quot;)])
# 提交，不然无法保存新建或者修改的数据
conn.commit()
# 关闭游标
cursor.close()
# 关闭连接
conn.close()
</code></pre>
<p><code>注意：存在中文的时候，连接需要添加charset='utf8'，否则中文显示乱码。</code></p>
<h3 id="获取查询数据">获取查询数据</h3>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
cursor.execute(&quot;select * from tb7&quot;)
# 获取剩余结果的第一行数据
row_1 = cursor.fetchone()
print row_1
# 获取剩余结果前n行数据
# row_2 = cursor.fetchmany(3)
# 获取剩余结果所有数据
# row_3 = cursor.fetchall()
conn.commit()
cursor.close()
conn.close()
</code></pre>
<h3 id="获取新创建数据自增id">获取新创建数据自增ID</h3>
<p>可以获取到最新自增的ID，也就是最后插入的一条数据ID</p>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
effect_row = cursor.executemany(&quot;insert into tb7(user,pass,licnese)values(%s,%s,%s)&quot;, [(&quot;u3&quot;,&quot;u3pass&quot;,&quot;11113&quot;),(&quot;u4&quot;,&quot;u4pass&quot;,&quot;22224&quot;)])
conn.commit()
cursor.close()
conn.close()
#获取自增id
new_id = cursor.lastrowid      
print new_id
</code></pre>
<h3 id="移动游标">移动游标</h3>
<p>操作都是靠游标，那对游标的控制也是必须的，<code>在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置</code>，如：</p>
<pre><code class="language-python">cursor.scroll(1,mode='relative') # 相对当前位置移动
cursor.scroll(2,mode='absolute') # 相对绝对位置移动
</code></pre>
<h3 id="fetch数据类型">fetch数据类型</h3>
<p>关于默认获取的数据是元祖类型，如果想要或者字典类型的数据，即：</p>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
#游标设置为字典类型
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
cursor.execute(&quot;select * from tb7&quot;)
row_1 = cursor.fetchone()
print row_1　　#{u'licnese': 213, u'user': '123', u'nid': 10, u'pass': '213'}
conn.commit()
cursor.close()
conn.close()
</code></pre>
<h3 id="调用存储过程">调用存储过程</h3>
<ul>
<li>调用无参存储过程</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
 
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
#游标设置为字典类型
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
#无参数存储过程
cursor.callproc('p2')  #等价于cursor.execute(&quot;call p2()&quot;)
row_1 = cursor.fetchone()
print row_1
conn.commit()
cursor.close()
conn.close()
</code></pre>
<ul>
<li>调用有参存储过程</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
 
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
cursor.callproc('p1', args=(1, 22, 3, 4))
#获取执行完存储的参数,参数@开头
cursor.execute(&quot;select @p1,@_p1_1,@_p1_2,@_p1_3&quot;)  #{u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}
row_1 = cursor.fetchone()
print row_1
conn.commit()
cursor.close()
conn.close()
</code></pre>
<h2 id="关于pymysql防注入">关于pymysql防注入</h2>
<h3 id="字符串拼接查询造成注入">字符串拼接查询，造成注入</h3>
<ul>
<li>正常查询语句：</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
user=&quot;u1&quot;
passwd=&quot;u1pass&quot;
#正常构造语句的情况
sql=&quot;select user,pass from tb7 where user='%s' and pass='%s'&quot; % (user,passwd)
#sql=select user,pass from tb7 where user='u1' and pass='u1pass'
row_count=cursor.execute(sql) row_1 = cursor.fetchone()
print row_count,row_1
conn.commit()
cursor.close()
conn.close()
</code></pre>
<ul>
<li>构造注入语句：</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
user=&quot;u1' or '1'-- &quot;
passwd=&quot;u1pass&quot;
sql=&quot;select user,pass from tb7 where user='%s' and pass='%s'&quot; % (user,passwd)
#拼接语句被构造成下面这样，永真条件，此时就注入成功了。因此要避免这种情况需使用pymysql提供的参数化查询。
#select user,pass from tb7 where user='u1' or '1'-- ' and pass='u1pass'
row_count=cursor.execute(sql)
row_1 = cursor.fetchone()
print row_count,row_1
conn.commit()
cursor.close()
conn.close()
</code></pre>
<h3 id="避免注入使用pymysql提供的参数化语句">避免注入，使用pymysql提供的参数化语句</h3>
<ul>
<li>正常参数化查询</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
 
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
user=&quot;u1&quot;
passwd=&quot;u1pass&quot;
#执行参数化查询
row_count=cursor.execute(&quot;select user,pass from tb7 where user=%s and pass=%s&quot;,(user,passwd))
row_1 = cursor.fetchone()
print row_count,row_1
conn.commit()
cursor.close()
conn.close()
</code></pre>
<ul>
<li>构造注入，参数化查询注入失败。</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
user=&quot;u1' or '1'-- &quot;
passwd=&quot;u1pass&quot;
#执行参数化查询
row_count=cursor.execute(&quot;select user,pass from tb7 where user=%s and pass=%s&quot;,(user,passwd))
#内部执行参数化生成的SQL语句，对特殊字符进行了加\转义，避免注入语句生成。
# sql=cursor.mogrify(&quot;select user,pass from tb7 where user=%s and pass=%s&quot;,(user,passwd))
# print sql
#select user,pass from tb7 where user='u1\' or \'1\'-- ' and pass='u1pass'被转义的语句。
row_1 = cursor.fetchone()
print row_count,row_1
conn.commit()
cursor.close()
</code></pre>
<p><code>结论：excute执行SQL语句的时候，必须使用参数化的方式，否则必然产生SQL注入漏洞。</code></p>
<h3 id="使用存mysql储过程动态执行sql防注入">使用存mysql储过程动态执行SQL防注入</h3>
<p>使用MYSQL存储过程自动提供防注入，动态传入SQL到存储过程执行语句。</p>
<pre><code class="language-SQL">delimiter \\
DROP PROCEDURE IF EXISTS proc_sql \\
CREATE PROCEDURE proc_sql (
  in nid1 INT,
  in nid2 INT,
  in callsql VARCHAR(255)
  )
BEGIN
  set @nid1 = nid1;
  set @nid2 = nid2;
  set @callsql = callsql;
    PREPARE myprod FROM @callsql;
--   PREPARE prod FROM 'select * from tb2 where nid&gt;? and nid&lt;?';  传入的值为字符串，？为占位符
--   用@p1，和@p2填充占位符
    EXECUTE myprod USING @nid1,@nid2;
  DEALLOCATE prepare myprod;
END\\
delimiter ;
</code></pre>
<pre><code class="language-SQL">set @nid1=12;
set @nid2=15;
set @callsql = 'select * from tb7 where nid&gt;? and nid&lt;?';
CALL proc_sql(@nid1,@nid2,@callsql)
</code></pre>
<p>pymsql中调用</p>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
import pymysql
 
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1')
cursor = conn.cursor()
mysql=&quot;select * from tb7 where nid&gt;? and nid&lt;?&quot;
cursor.callproc('proc_sql', args=(11, 15, mysql))
rows = cursor.fetchall()
print rows #((12, 'u1', 'u1pass', 11111), (13, 'u2', 'u2pass', 22222), (14, 'u3', 'u3pass', 11113))
conn.commit()
cursor.close()
conn.close()
</code></pre>
<h2 id="使用with简化连接过程">使用with简化连接过程</h2>
<p>每次都连接关闭很麻烦，使用上下文管理，简化连接过程</p>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
 
import pymysql
import contextlib
#定义上下文管理器，连接后自动关闭连接
@contextlib.contextmanager
def mysql(host='127.0.0.1', port=3306, user='root', passwd='', db='tkq1',charset='utf8'):
  conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
  cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
  try:
    yield cursor
  finally:
    conn.commit()
    cursor.close()
    conn.close()
 
# 执行sql
with mysql() as cursor:
  print(cursor)
  row_count = cursor.execute(&quot;select * from tb7&quot;)
  row_1 = cursor.fetchone()
  print row_count, row_1
</code></pre>
<h2 id="参考">参考</h2>
<p>使用方法参考[Python中操作mysql的pymysql模块详解](https:// www.jb51.net/article/92516.htm)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python常用模块&框架]]></title>
        <id>https://dingdingtao.github.io/post/python-kuang-jia/</id>
        <link href="https://dingdingtao.github.io/post/python-kuang-jia/">
        </link>
        <updated>2021-03-02T06:28:26.000Z</updated>
        <summary type="html"><![CDATA[<center>
整理包括Django、等框架
</center>
]]></summary>
        <content type="html"><![CDATA[<center>
整理包括Django、等框架
</center>
<!-- more -->
<h2 id="python模块">Python模块</h2>
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://dingdingtao.github.io/post/pymysql-shu-ju-ku-lian-jie/">pymysql</a></td>
<td style="text-align:center">数据库连接</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://dingdingtao.github.io/post/pandas-shu-ju-chu-li/">pandas</a></td>
<td style="text-align:center">数据处理</td>
</tr>
</tbody>
</table>
<h2 id="python框架">Python框架</h2>
<ul>
<li><a href="https://dingdingtao.github.io/tag/Python/Django">Django</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django参考]]></title>
        <id>https://dingdingtao.github.io/post/django-can-kao/</id>
        <link href="https://dingdingtao.github.io/post/django-can-kao/">
        </link>
        <updated>2021-03-02T06:19:22.000Z</updated>
        <summary type="html"><![CDATA[<center>
Django安装、创建项目、目录结构及简单使用方法
</center>
]]></summary>
        <content type="html"><![CDATA[<center>
Django安装、创建项目、目录结构及简单使用方法
</center>
<!-- more -->
<h2 id="安装django">安装django</h2>
<pre><code class="language-text">pip3 install Django==3.0.6 -i https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h2 id="创建项目">创建项目</h2>
<pre><code class="language-text">django-admin.py startproject testdj
</code></pre>
<p><strong>目录结构</strong></p>
<pre><code class="language-text">|-- HelloWorld
|   |-- __init__.py
|   |-- asgi.py
|   |-- settings.py
|   |-- urls.py
|   |-- wsgi.py
|-- manage.py
</code></pre>
<p><strong>目录说明</strong></p>
<ul>
<li><code>HelloWorld</code>: 项目的容器。</li>
<li><code>manage.py</code>: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。</li>
<li><code>HelloWorld/__init__.py</code>: 一个空文件，告诉 Python 该目录是一个 Python 包。</li>
<li><code>HelloWorld/asgi.py</code>: 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。</li>
<li><code>HelloWorld/settings.py</code>: 该 Django 项目的设置/配置。</li>
<li><code>HelloWorld/urls.py</code>: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。</li>
<li><code>HelloWorld/wsgi.py</code>: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。</li>
</ul>
<h2 id="启动">启动</h2>
<pre><code class="language-text">python manage.py runserver [ip:port]
</code></pre>
<h2 id="视图">视图</h2>
<p>创建视图文件HelloWorld/HelloWorld/views.py</p>
<pre><code class="language-python">'''引入HttpResponse'''
from django.http import HttpResponse
 '''视图函数'''
def hello(request):
    '''
    
    '''
    return HttpResponse(&quot;Hello world ! &quot;)
</code></pre>
<h3 id="视图函数">视图函数</h3>
<p>视图层中有两个重要的对象：<br>
请求对象(request): 视图函数的固定第一参数。<br>
响应对象(HttpResponse): 视图函数返回内容。</p>
<p><strong>请求对象</strong><br>
常用的 request 属性<br>
<code>GET</code>: 数据类型是 QueryDict，一个类似于字典的对象，包含 HTTP GET 的所有参数。<br>
有相同的键，就把所有的值放到对应的列表里。<br>
取值格式：对象.方法。<br>
get()：返回字符串，如果该键对应有多个值，取出该键的最后一个值。</p>
<pre><code class="language-python">def runoob(request):
    name = request.GET.get(&quot;name&quot;)
    return HttpResponse('姓名：{}'.format(name))
</code></pre>
<p><code>POST</code>: 数据类型是 QueryDict，一个类似于字典的对象，包含 HTTP POST 的所有参数。<br>
常用于 form 表单，form 表单里的标签 name 属性对应参数的键，value 属性对应参数的值。<br>
取值格式： 对象.方法。<br>
get()：返回字符串，如果该键对应有多个值，取出该键的最后一个值。</p>
<pre><code class="language-python">def runoob(request):
    name = request.POST.get(&quot;name&quot;)
    return HttpResponse('姓名：{}'.format(name))
</code></pre>
<p><code>body</code>: 数据类型是二进制字节流，是原生请求体里的参数内容，在 HTTP 中用于 POST，因为 GET 没有请求体。<br>
在 HTTP 中不常用，而在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML、Json 等。</p>
<pre><code class="language-python">def runoob(request):
    name = request.body
    print(name)
    return HttpResponse(&quot;菜鸟教程&quot;)
</code></pre>
<p><code>path</code>: 获取 URL 中的路径部分(不包括域名端口等)，数据类型是字符串。</p>
<pre><code class="language-python">def runoob(request):
    name = request.path
    print(name)
    return HttpResponse(&quot;菜鸟教程&quot;)
</code></pre>
<p><code>method</code>:  获取当前请求的方式，数据类型是字符串，且结果为大写。</p>
<pre><code class="language-python">def runoob(request):
    name = request.method
    print(name)
    return HttpResponse(&quot;菜鸟教程&quot;)
</code></pre>
<p><strong>响应对象</strong><br>
<code>HttpResponse()</code>: 返回文本，参数为字符串，字符串中写文本内容。如果参数为字符串里含有 html 标签，也可以渲染。</p>
<p><code>render()</code>: 返回文本，第一个参数为 request，第二个参数为字符串（页面名称），第三个参数为字典（可选参数，向页面传递的参数：键为页面参数名，值为views参数名）。</p>
<p><code>redirect()</code>：重定向，跳转新页面。参数为字符串，字符串中填写页面路径。一般用于 form 表单提交后，跳转到新页面。</p>
<h2 id="url路由">URL路由</h2>
<p>绑定 URL 与视图函数</p>
<pre><code class="language-python">'''引入url'''
from django.conf.urls import url
'''从当前目录引入views视图文件'''
from . import views
'''配置url与视图对应关系'''
urlpatterns = [
    '''
    url(请求路径, 视图函数)
    '''
    url(r'^$', views.hello),
]
</code></pre>
<p><strong>路由</strong><br>
<code>url()</code>: 普通路径和正则路径均可使用，需要自己手动添加正则首位限制符号。</p>
<pre><code class="language-python">from django.conf.urls import url # 用 url 需要引入

urlpatterns = [
    url(r'^admin/$', admin.site.urls),
    url(r'^index/$', views.index), # 普通路径
    url(r'^articles/([0-9]{4})/$', views.articles), # 正则路径
]
</code></pre>
<p><code>path()</code>：用于普通路径，不需要自己手动添加正则首位限制符号，底层已经添加。<br>
<code>re_path</code>：用于正则路径，需要自己手动添加正则首位限制符号。</p>
<pre><code class="language-python">from django.urls import re_path # 用re_path 需要引入
urlpatterns = [
    path('admin/', admin.site.urls),
    path('index/', views.index), # 普通路径
    re_path(r'^articles/([0-9]{4})/$', views.articles), # 正则路径
]
</code></pre>
<p><strong>路径分组</strong></p>
<p>正则路径中的无名分组</p>
<pre><code class="language-python">urlpatterns = [
    path('admin/', admin.site.urls),
    re_path(&quot;^index/([0-9]{4})/$&quot;, views.index),
]

from django.shortcuts import HttpResponse

def index(request，year):
    print(year) # 一个形参代表路径中一个分组的内容，按顺序匹配
    return HttpResponse('菜鸟教程')

</code></pre>
<p>正则路径中的有名分组</p>
<pre><code class="language-python">urlpatterns = [
    path('admin/', admin.site.urls),
    re_path(&quot;^index/(?P[0-9]{4})/(?P[0-9]{2})/$&quot;, views.index),
]

from django.shortcuts import HttpResponse
def index(request, year, month):
    print(year,month) # 一个形参代表路径中一个分组的内容，按关键字对应匹配
    return HttpResponse('菜鸟教程')
</code></pre>
<p><strong>路由分发</strong><br>
存在问题：Django 项目里多个app目录共用一个 urls 容易造成混淆，后期维护也不方便。<br>
解决：使用路由分发（include），让每个app目录都单独拥有自己的 urls。<br>
步骤：</p>
<ol>
<li>在每个 app 目录里都创建一个 urls.py 文件。</li>
<li>在项目名称目录下的 urls 文件里，统一将路径分发给各个 app 目录。</li>
</ol>
<pre><code class="language-python">from django.contrib import admin
from django.urls import path,include # 从 django.urls 引入 include
urlpatterns = [
    path('admin/', admin.site.urls),
    path(&quot;app01/&quot;, include(&quot;app01.urls&quot;)),
    path(&quot;app02/&quot;, include(&quot;app02.urls&quot;)),
]
</code></pre>
<p><strong>反向解析</strong></p>
<p><strong>命名空间</strong></p>
<h2 id="模版">模版</h2>
<p><strong>模版目录</strong><br>
项目目录下创建templates目录,修改 TEMPLATES 中的 DIRS 为 [os.path.join(BASE_DIR, 'templates')],将模版目录修改为templates。</p>
<pre><code class="language-conf">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')], # 修改位置
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre>
<p><strong>创建模版文件</strong><br>
参考<a href="https://www.runoob.com/django/django-template.html">模版标签</a></p>
<p><strong>向模板提交数据</strong></p>
<pre><code class="language-python">from django.shortcuts import render
 
def runoob(request):
    context          = {}
    context['hello'] = 'Hello World!'
    return render(request, 'runoob.html', context)
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://www.runoob.com/django/django-tutorial.html">django参考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hive时间处理函数]]></title>
        <id>https://dingdingtao.github.io/post/hive-shi-jian-chu-li-han-shu/</id>
        <link href="https://dingdingtao.github.io/post/hive-shi-jian-chu-li-han-shu/">
        </link>
        <updated>2021-03-02T03:47:20.000Z</updated>
        <summary type="html"><![CDATA[<center>常用的hive时间处理函数</center>
]]></summary>
        <content type="html"><![CDATA[<center>常用的hive时间处理函数</center>
<!-- more -->
<h2 id="from_unixtime-时间戳转日期">from_unixtime (时间戳转日期)</h2>
<p>语法：<code>from_unixtime(bigint unixtime[, string pattern])</code><br>
返回值：string<br>
说明：转化UNIX时间戳（从1970-01-0100:00:00 UTC到指定时间的秒数）到当前时区的时间格式。</p>
<pre><code class="language-SQL">select from_unixtime(1614657355, 'yyyy-MM-dd HH:mm:ss') from table_name
&gt; 2021-03-02 11:55:55
</code></pre>
<h2 id="unix_timestamp-日期转时间戳">unix_timestamp (日期转时间戳)</h2>
<p>语法：<code>unix_timestamp([[string datetime], string pattern])</code><br>
返回值：bigint<br>
说明：转化UNIX时间戳（从1970-01-0100:00:00 UTC到指定时间的秒数）到当前时区的时间格式。</p>
<pre><code class="language-SQL">-- 默认当前时间戳
select unix_timestamp() from table

-- 指定时间的时间戳
select unix_timestamp('2021-03-02 11:55:55') from table
&gt; 1614657355
select unix_timestamp('2021-03-02 11:55:55', 'yyyy-MM-dd HH:mm:ss') from table
&gt; 1614657355
</code></pre>
<h2 id="to_date-字符串转日期">to_date (字符串转日期)</h2>
<p>语法：<code>to_date(string datetime)</code><br>
返回值：string<br>
说明：返回字符串格式日期时间字段中的日期部分。</p>
<pre><code class="language-SQL">select to_date('2021-03-02 11:55:55') from table
&gt; 2021-03-02
</code></pre>
<h2 id="year-返回日期中的年">year (返回日期中的年)</h2>
<p>语法：<code>year(string datetime)</code><br>
返回值：int<br>
说明：返回日期中的年。</p>
<pre><code class="language-SQL">select year('2021-03-02 11:55:55') from table
&gt; 2021
select year('2021-03-02') from table
&gt; 2021
</code></pre>
<h2 id="month-返回日期中的月份">month (返回日期中的月份)</h2>
<p>语法：<code>month(string datetime)</code><br>
返回值：int<br>
说明：返回日期中的月份。</p>
<pre><code class="language-SQL">select month('2021-03-02 11:55:55') from table
&gt; 3
select month('2021-03-02') from table
&gt; 3
</code></pre>
<h2 id="day-返回日期中的天">day (返回日期中的天)</h2>
<p>语法：<code>day(string datetime)</code><br>
返回值：int<br>
说明：返回日期中的天。</p>
<pre><code class="language-SQL">select day('2021-03-02 11:55:55') from table
&gt; 2
select day('2021-03-02') from table
&gt; 2
</code></pre>
<h2 id="hour-日期中的小时">hour (日期中的小时)</h2>
<p>语法：<code>hour(string datetime)</code><br>
返回值：int<br>
说明：返回日期中的小时。</p>
<pre><code class="language-SQL">select hour('2021-03-02 11:55:55') from table
&gt; 11
</code></pre>
<h2 id="minute-日期中的分钟">minute (日期中的分钟)</h2>
<p>语法：<code>minute(string datetime)</code><br>
返回值：int<br>
说明：返回日期中的分钟。</p>
<pre><code class="language-SQL">select minute('2021-03-02 11:55:55') from table
&gt; 55
</code></pre>
<h2 id="second-日期中的秒">second (日期中的秒)</h2>
<p>语法：<code>second(string datetime)</code><br>
返回值：int<br>
说明：返回日期中的秒。</p>
<pre><code class="language-SQL">select second('2021-03-02 11:55:55') from table
&gt; 55
</code></pre>
<h2 id="weekofyear-日期在当前的周数">weekofyear (日期在当前的周数)</h2>
<p>语法：<code>weekofyear(string datetime)</code><br>
返回值：int<br>
说明：返回日期在当前的周数。</p>
<pre><code class="language-SQL">select weekofyear('2021-03-02 11:55:55') from table
&gt; 10
</code></pre>
<h2 id="datediff-日期比较">datediff (日期比较)</h2>
<p>语法：<code>datediff(string enddate,string startdate)</code><br>
返回值：int<br>
说明：返回结束日期减去开始日期的天数。</p>
<pre><code class="language-SQL">select datediff('2021-02-28', '2021-03-02') from table
&gt; 3
</code></pre>
<h2 id="date_add-日期增加">date_add (日期增加)</h2>
<p>语法：<code>date_add(string startdate, int days)</code><br>
返回值：string<br>
说明：返回开始日期startdate增加days天后的日期。</p>
<pre><code class="language-SQL">select date_add('2021-02-28', 1) from table
&gt; 2021-03-01
</code></pre>
<h2 id="date_sub-日期减少">date_sub (日期减少)</h2>
<p>语法：<code>date_sub(string startdate, int days)</code><br>
返回值：string<br>
说明：返回开始日期startdate减少days天后的日期。</p>
<pre><code class="language-SQL">select date_sub('2021-02-28', 1) from table
&gt; 2021-02-27
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hive窗口函数]]></title>
        <id>https://dingdingtao.github.io/post/hive-chuang-kou-han-shu/</id>
        <link href="https://dingdingtao.github.io/post/hive-chuang-kou-han-shu/">
        </link>
        <updated>2021-03-01T02:01:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ntile">NTILE</h1>
<p>NTILE(n)，用于将分组数据按照顺序切分成n片，返回当前切片值<br>
NTILE不支持ROWS BETWEEN，比如 NTILE(2) OVER(PARTITION BY cookieid ORDER BY createtime ROWS BETWEEN 3 PRECEDING AND CURRENT ROW)<br>
如果切片不均匀，默认增加第一个切片的分布</p>
<pre><code class="language-SQL">SELECT 
cookieid,
createtime,
pv,
NTILE(2) OVER(PARTITION BY cookieid ORDER BY createtime) AS rn1,	--分组内将数据分成2片
NTILE(3) OVER(PARTITION BY cookieid ORDER BY createtime) AS rn2,  --分组内将数据分成3片
NTILE(4) OVER(ORDER BY createtime) AS rn3        --将所有数据分成4片
FROM lxw1234 
ORDER BY cookieid,createtime;
 
cookieid day           pv       rn1     rn2     rn3
-------------------------------------------------
cookie1 2015-04-10      1       1       1       1
cookie1 2015-04-11      5       1       1       1
cookie1 2015-04-12      7       1       1       2
cookie1 2015-04-13      3       1       2       2
cookie1 2015-04-14      2       2       2       3
cookie1 2015-04-15      4       2       3       3
cookie1 2015-04-16      4       2       3       4
cookie2 2015-04-10      2       1       1       1
cookie2 2015-04-11      3       1       1       1
cookie2 2015-04-12      5       1       1       2
cookie2 2015-04-13      6       1       2       2
cookie2 2015-04-14      3       2       2       3
cookie2 2015-04-15      9       2       3       4
cookie2 2015-04-16      7       2       3       4
</code></pre>
<p>–比如，统计一个cookie，pv数最多的前1/3的天</p>
<pre><code class="language-SQL">SELECT 
cookieid,
createtime,
pv,
NTILE(3) OVER(PARTITION BY cookieid ORDER BY pv DESC) AS rn 
FROM lxw1234;
 
--rn = 1 的记录，就是我们想要的结果
 
cookieid day           pv       rn
----------------------------------
cookie1 2015-04-12      7       1
cookie1 2015-04-11      5       1
cookie1 2015-04-15      4       1
cookie1 2015-04-16      4       2
cookie1 2015-04-13      3       2
cookie1 2015-04-14      2       3
cookie1 2015-04-10      1       3
cookie2 2015-04-15      9       1
cookie2 2015-04-16      7       1
cookie2 2015-04-13      6       1
cookie2 2015-04-12      5       2
cookie2 2015-04-14      3       2
cookie2 2015-04-11      3       3
cookie2 2015-04-10      2       3
</code></pre>
<h1 id="row_number">ROW_NUMBER</h1>
<p>ROW_NUMBER() –从1开始，按照顺序，生成分组内记录的序列<br>
–比如，按照pv降序排列，生成分组内每天的pv名次<br>
ROW_NUMBER() 的应用场景非常多，再比如，获取分组内排序第一的记录;获取一个session中的第一条refer等。</p>
<pre><code class="language-SQL">SELECT 
cookieid,
createtime,
pv,
ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn 
FROM lxw1234;
 
cookieid day           pv       rn
------------------------------------------- 
cookie1 2015-04-12      7       1
cookie1 2015-04-11      5       2
cookie1 2015-04-15      4       3
cookie1 2015-04-16      4       4
cookie1 2015-04-13      3       5
cookie1 2015-04-14      2       6
cookie1 2015-04-10      1       7
cookie2 2015-04-15      9       1
cookie2 2015-04-16      7       2
cookie2 2015-04-13      6       3
cookie2 2015-04-12      5       4
cookie2 2015-04-14      3       5
cookie2 2015-04-11      3       6
cookie2 2015-04-10      2       7
</code></pre>
<h1 id="rank-和-dense_rank">RANK 和 DENSE_RANK</h1>
<p>—RANK() 生成数据项在分组中的排名，排名相等会在名次中留下空位<br>
—DENSE_RANK() 生成数据项在分组中的排名，排名相等会在名次中不会留下空位</p>
<pre><code class="language-SQL">SELECT 
cookieid,
createtime,
pv,
RANK() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn1,
DENSE_RANK() OVER(PARTITION BY cookieid ORDER BY pv desc) AS rn2,
ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY pv DESC) AS rn3 
FROM lxw1234 
WHERE cookieid = 'cookie1';
 
cookieid day           pv       rn1     rn2     rn3 
-------------------------------------------------- 
cookie1 2015-04-12      7       1       1       1
cookie1 2015-04-11      5       2       2       2
cookie1 2015-04-15      4       3       3       3
cookie1 2015-04-16      4       3       3       4
cookie1 2015-04-13      3       5       4       5
cookie1 2015-04-14      2       6       5       6
cookie1 2015-04-10      1       7       6       7
 
rn1: 15号和16号并列第3, 13号排第5
rn2: 15号和16号并列第3, 13号排第4
rn3: 如果相等，则按记录值排序，生成唯一的次序，如果所有记录值都相等，或许会随机排吧。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hive内置函数]]></title>
        <id>https://dingdingtao.github.io/post/hive-nei-zhi-han-shu/</id>
        <link href="https://dingdingtao.github.io/post/hive-nei-zhi-han-shu/">
        </link>
        <updated>2021-03-01T02:00:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="内置函数">内置函数</h2>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>签名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIGINT</td>
<td>round(double a)</td>
<td>返回BIGINT最近的double值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>floor(double a)</td>
<td>返回最大BIGINT值等于或小于double</td>
</tr>
<tr>
<td>BIGINT</td>
<td>ceil(double a)</td>
<td>返回最小BIGINT值等于或大于double</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>rand(),rand(int seed)</td>
<td>它返回一个随机数，从行改变到行</td>
</tr>
<tr>
<td>STRING</td>
<td>concat(string A,string B,...)</td>
<td>它返回从A后串联B产生的字符串</td>
</tr>
<tr>
<td>STRING</td>
<td>substr(string A,int start)</td>
<td>它返回一个起始，从起始位置的子字符串，直到A结束</td>
</tr>
<tr>
<td>STRING</td>
<td>substr(string A, int start, int length)</td>
<td>返回从给定长度的起始start位置开始的字符串</td>
</tr>
<tr>
<td>STRING</td>
<td>upper(string A)</td>
<td>它返回从转换的所有字符为大写产生的字符串</td>
</tr>
<tr>
<td>STRING</td>
<td>ucase(string A)</td>
<td>和上面的一样</td>
</tr>
<tr>
<td>STRING</td>
<td>lower(string A)</td>
<td>它返回转换B的所有字符为小写产生的字符串</td>
</tr>
<tr>
<td>STRING</td>
<td>lcase(string A)</td>
<td>和上面的一样</td>
</tr>
<tr>
<td>STRING</td>
<td>trim(string A)</td>
<td>它返回字符串从A.两端修剪空格的结果</td>
</tr>
<tr>
<td>STRING</td>
<td>ltrim(string A)</td>
<td>它返回A从一开始修整空格产生的字符串(左手侧)</td>
</tr>
<tr>
<td>STRING</td>
<td>rtrim(string A)</td>
<td>它返回A从结束修整空格产生的字符串(右侧)</td>
</tr>
<tr>
<td>STRING</td>
<td>regexp_replace(string A, string B, string C)</td>
<td>它返回从替换所有子在B结果配合C.在Java正则表达式语法的字符串</td>
</tr>
<tr>
<td>INT</td>
<td>size(Map&lt;K,V&gt;)</td>
<td>它返回在映射类型的元素的数量</td>
</tr>
<tr>
<td>INT</td>
<td>size(Array<T>)</td>
<td>它返回在数组类型元素的数量</td>
</tr>
<tr>
<td>value of <type></td>
<td>cast(<expr> as <type>)</td>
<td>它把表达式的结果expr&lt;类型&gt;如cast('1'作为BIGINT)代表整体转换为字符串'1'。如果转换不成功，返回的是NULL</td>
</tr>
<tr>
<td>STRING</td>
<td>from_unixtime(int unixtime)</td>
<td>转换的秒数从Unix纪元(1970-01-0100:00:00 UTC)代表那一刻，在当前系统时区的时间戳字符的串格式：&quot;1970-01-01 00:00:00&quot;</td>
</tr>
<tr>
<td>STRING</td>
<td>to_date(string timestamp)</td>
<td>返回一个字符串时间戳的日期部分：to_date(&quot;1970-01-01 00:00:00&quot;) = &quot;1970-01-01&quot;</td>
</tr>
<tr>
<td>INT</td>
<td>year(string date)</td>
<td>返回年份部分的日期或时间戳字符串：year(&quot;1970-01-01 00:00:00&quot;) = 1970, year(&quot;1970-01-01&quot;) = 1970</td>
</tr>
<tr>
<td>INT</td>
<td>month(string date)</td>
<td>返回日期或时间戳记字符串月份部分：month(&quot;1970-11-01 00:00:00&quot;) = 11, month(&quot;1970-11-01&quot;) = 11</td>
</tr>
<tr>
<td>INT</td>
<td>day(string date)</td>
<td>返回日期或时间戳记字符串当天部分：day(&quot;1970-11-01 00:00:00&quot;) = 1, day(&quot;1970-11-01&quot;) = 1</td>
</tr>
<tr>
<td>STRING</td>
<td>get_json_object(string json_string, string path)</td>
<td>提取从基于指定的JSON路径的JSON字符串JSON对象，并返回提取的JSON字符串的JSON对象。如果输入的JSON字符串无效，返回NULL</td>
</tr>
</tbody>
</table>
<h2 id="聚合函数">聚合函数</h2>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>签名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIGINT</td>
<td>count(*), count(expr)</td>
<td>返回检索行的总数</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>sum(col), sum(DISTINCT col)</td>
<td>返回该组或该组中的列的不同值的分组和所有元素的总和</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>avg(col), avg(DISTINCT col)</td>
<td>返回上述组或该组中的列的不同值的元素的平均值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>min(col)</td>
<td>返回该组中的列的最小值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>max(col)</td>
<td>返回该组中的列的最大值</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>