<html>
  <head>
    <meta charset="utf-8" />
<!-- <meta name="viewport" content="width=device-width, initial-scale=1" /> -->
<meta name="viewport" content="width=device-width" /> 
<title>Pandas数据处理 | dingdingtao的个人静态网站</title>
<link rel="shortcut icon" href="https://dingdingtao.github.io/favicon.ico?v=1616129195499">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dingdingtao.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Pandas数据处理 | dingdingtao的个人静态网站 - Atom Feed" href="https://dingdingtao.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">

<!-- gitalk -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<!-- gitalk -->
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

<!-- 点击特效 -->
<!-- 爱心 -->
<script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>

<!-- 看板 -->
<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script>
<!-- 看板配置 -->
<script>
    L2Dwidget.init({
        "model": {
            jsonPath: "https://unpkg.com/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json",
            "scale": 1
        },
        "display": {
            "position": "right",
            "width": 200,
            "height": 400,
            "hOffset": -30,
            "vOffset": -80
        },
        "mobile": {
            "show": true,
            "scale": 0.3
        },
        "react": {
            "opacityDefault": 0.7,
            "opacityOnHover": 0.2
        }
    });
</script>
<!--
黑猫：https://unpkg.com/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json
萌娘：https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json
白猫：https://unpkg.com/live2d-widget-model-tororo@1.0.5/assets/tororo.model.json
狗狗：https://unpkg.com/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json
小可爱：https://unpkg.com/live2d-widget-model-z16@1.0.5/assets/z16.model.json
小可爱：https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json
-->



    <meta name="description" content="
pandas模块的简单使用、常用函数、数据处理等


介绍
在Python中，pandas是基于NumPy数组构建的，使数据预处理、清洗、分析工作变得更快更简单。pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数..." />
    <meta name="keywords" content="Python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dingdingtao.github.io">
  <img class="avatar" src="https://dingdingtao.github.io/images/avatar.png?v=1616129195499" alt="">
  </a>
  <h1 class="site-title">
    dingdingtao的个人静态网站
  </h1>
  <p class="site-description">
    快快长大
  </p>
  <div class="menu-container">
    
      
        <a href="https://dingdingtao.github.io" class="menu">
          列表
        </a>
      
    
      
        <a href="https://dingdingtao.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dingdingtao.github.io/archives" class="menu">
          时间线
        </a>
      
    
      
        <a href="https://dingdingtao.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/dingdingtao" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Pandas数据处理
            </h2>
            <div class="post-info">
              <span>
                2021-03-02
              </span>
              <span>
                21 min read
              </span>
              
                <a href="https://dingdingtao.github.io/tag/Python/" class="post-tag">
                  # Python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <center>
pandas模块的简单使用、常用函数、数据处理等
</center>
<!-- more -->
<h2 id="介绍">介绍</h2>
<p>在Python中，pandas是基于NumPy数组构建的，使数据预处理、清洗、分析工作变得更快更简单。pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。<br>
使用下面格式约定，引入pandas包：</p>
<pre><code class="language-python">import pandas as pd
</code></pre>
<p><strong>pandas有两个主要数据结构：Series和DataFrame。</strong></p>
<h2 id="series">Series</h2>
<p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成，即index和values两部分，可以通过索引的方式选取Series中的单个或一组值。</p>
<h2 id="dataframe">DataFrame</h2>
<p>DataFrame是一个表格型的数据类型，每列值类型可以不同，是最常用的pandas对象。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p>
<h3 id="dataframe的创建">DataFrame的创建</h3>
<p>pd.DataFrame(data,columns = [ ],index = [ ])：columns和index为指定的列、行索引，并按照顺序排列。</p>
<ul>
<li>创建DataFrame最常用的是直接传入一个由等长列表或NumPy数组组成的<strong>字典</strong>，会自动加上行索引，字典的<strong>键</strong>会被当做列 <strong>索引</strong>：</li>
</ul>
<pre><code class="language-python">import pandas as pd
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
df= pd.DataFrame(data)
In [45]: df
Out[45]: 
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002
5  3.2  Nevada  2003
</code></pre>
<p>如果创建时指定了columns和index索引，则按照索引顺序排列，并且如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<pre><code class="language-python">In [48]: df2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
   ....:                       index=['one', 'two', 'three', 'four', 'five', 'six'])
In [49]: df2
Out[49]: 
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN
</code></pre>
<p>另一种常见的创建DataFrame方式是使用嵌套字典，如果嵌套字典传给DataFrame，pandas就会被解释为外层字典的键作为列，内层字典键则作为行索引：</p>
<pre><code class="language-python">In [65]: pop = {'Nevada': {2001: 2.4, 2002: 2.9},
....:        'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}
In [66]: df3 = pd.DataFrame(pop)
In [67]: df3
Out[67]: 
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6
</code></pre>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>二维ndarray</td>
<td>数据矩阵，还可以传入行标和列标</td>
</tr>
<tr>
<td>由数组、列表或元组组成的字典</td>
<td>每个序列会变成DataFrame的一列。所有序列的长度必须相同</td>
</tr>
<tr>
<td>NumPy的结构化/记录数组</td>
<td>类似于“由数组组成的字典”</td>
</tr>
<tr>
<td>由Series组成的字典</td>
<td>每个Series会成为一列。如果没有显式指定索引，则各Series的索引会被合并成结果的行索引</td>
</tr>
<tr>
<td>由字典组成的字典</td>
<td>各内层字典会成为一列。键会被合并成结果的行索引，跟“由Series组成的字典”的情况一样</td>
</tr>
<tr>
<td>字典或Series的列表</td>
<td>各项将会成为DataFrame的一行。字典键或Series索引的并集将会成为DataFrame的列标</td>
</tr>
<tr>
<td>由列表或元组组成的列表</td>
<td>类似于“二维ndarray”</td>
</tr>
<tr>
<td>另一个DataFrame</td>
<td>该DataFrame的索引将会被沿用，除非显式指定了其他索引</td>
</tr>
<tr>
<td>NumPy的MaskedArray</td>
<td>类似于“二维ndarray”的情况，只是掩码值在结果DataFrame会变成NA/缺失值</td>
</tr>
</tbody>
</table>
<h3 id="dataframe对象操作">DataFrame对象操作</h3>
<ul>
<li>df.values：将DataFrame转换为ndarray二维数组，注意后面不加()。</li>
<li>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。</li>
<li>列可以通过赋值的方式进行修改。例如，我们可以给那个空的&quot;debt&quot;列赋上一个标量值或一组值。</li>
<li>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值。</li>
<li>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</li>
</ul>
<pre><code class="language-python">import pandas as pd
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
In [48]: df2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
   ....:                       index=['one', 'two', 'three', 'four', 'five', 'six'])

In [50]: df2.columns
Out[50]: Index(['year', 'state', 'pop', 'debt'], dtype='object')
#通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。
In [51]: df2['state']  #或者df2.state
Out[51]: 
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
#列可以通过赋值的方式进行修改。例如，我们可以给那个空的&quot;debt&quot;列赋上一个标量值或一组值
In [54]: frame2['debt'] = 16.5
In [55]: frame2
Out[55]: 
       year   state  pop  debt
one    2000    Ohio  1.5  16.5
two    2001    Ohio  1.7  16.5
three  2002    Ohio  3.6  16.5
four   2001  Nevada  2.4  16.5
five   2002  Nevada  2.9  16.5
six    2003  Nevada  3.2  16.5
#将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值
In [58]: val = pd.Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
In [59]: df2['debt'] = val
In [60]: df2
Out[60]: 
       year   state  pop  debt
one    2000    Ohio  1.5   16.5
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   16.5
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7
six    2003  Nevada  3.2   16.5
#为不存在的列赋值，会创建出一个新列
In [61]: df2['eastern'] = df2.state == 'Ohio'
In [62]: df2
Out[62]: 
       year   state  pop  debt  eastern
one    2000    Ohio  1.5   NaN     True
two    2001    Ohio  1.7  -1.2     True
three  2002    Ohio  3.6   NaN     True
four   2001  Nevada  2.4  -1.5    False
five   2002  Nevada  2.9  -1.7    False
six    2003  Nevada  3.2   NaN    False
#关键字del用于删除列
In [63]: del df2['eastern']
In [64]: df2.columns
Out[64]: Index(['year', 'state', 'pop', 'debt'], dtype='object')
</code></pre>
<h2 id="pandas的基本功能">pandas的基本功能</h2>
<p><strong>数据索引</strong>:Series和DataFrame的索引是Index类型，Index对象是不可修改，可通过索引值或索引标签获取目标数据，也可通过索引使序列或数据框的计算、操作实现自动化对齐。索引类型index的常用方法：</p>
<ul>
<li>.append(idx)：连接另一个Index对象，产生新的Index对象</li>
<li>.diff(idx)：计算差集，产生新的Index对象</li>
<li>.intersection(idx)：计算交集</li>
<li>.union(idx)：计算并集</li>
<li>.delete(loc)：删除loc位置处的元素</li>
<li>.insert(loc,e)：在loc位置增加一个元素<br>
<strong>重新索引</strong>:能够改变、重排Series和DataFrame索引，会创建一个新对象，如果某个索引值当前不存在，就引入缺失值。<br>
<strong>df.reindex(index, columns ,fill_value, method, limit, copy )</strong>:index/columns为新的行列自定义索引；fill_value为用于填充缺失位置的值；method为填充方法，ffill当前值向前填充，bfill向后填充；limit为最大填充量；copy 默认True，生成新的对象，False时，新旧相等不复制。</li>
</ul>
<pre><code class="language-python">In [98]: frame = pd.DataFrame(np.arange(9).reshape((3, 3)),
   ....:                      index=['a', 'c', 'd'],columns=['Ohio', 'Texas', 'California'])
In [99]: frame
Out[99]: 
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8

In [100]: frame2 = frame.reindex(['a', 'b', 'c', 'd'])
In [101]: frame2
Out[101]: 
   Ohio  Texas  California
a   0.0    1.0         2.0
b   NaN    NaN         NaN
c   3.0    4.0         5.0
d   6.0    7.0         8.0
</code></pre>
<p><strong>删除指定索引</strong>:默认返回的是一个新对象。<br>
<strong>.drop()</strong>:能够删除Series和DataFrame指定行或列索引。<br>
删除一行或者一列时，用单引号指定索引，删除多行时用列表指定索引。<br>
如果删除的是列索引，需要增加axis=1或axis='columns'作为参数。<br>
增加inplace=True作为参数，可以就地修改对象，不会返回新的对象。<br>
<strong>索引、选取和过滤</strong><br>
<strong>df.loc[行标签，列标签]</strong>:通过标签查询指定的数据，第一个值为行标签，第二值为列标签。当第二个参数为空时，查询的是单个或多个行的所有列。如果查询多个行、列的话，则两个参数用列表表示。<br>
<strong>df.iloc[行位置，列位置]</strong>:通过默认生成的数字索引查询指定的数据。</p>
<pre><code class="language-python">In [128]: data = pd.DataFrame(np.arange(16).reshape((4, 4)),
   .....:                     index=['Ohio', 'Colorado', 'Utah', 'New York'],
   .....:                     columns=['one', 'two', 'three', 'four'])
​
In [129]: data
Out[129]: 
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
#df.loc选取第二行、第二三列
In [137]: data.loc['Colorado', ['two', 'three']]   
Out[137]: 
two      5
three    6
Name: Colorado, dtype: int64
#df.iloc选取第二行、第二三列
In [138]: data.iloc[1, [1, 2]]
Out[138]: 
two      5
three    6
Name: Colorado, dtype: int64
</code></pre>
<p>在pandas中，有多个方法可以选取和重新组合数据:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>df[val]</td>
<td>从DataFrame选取单列或一组列；在特殊情况下比较便利：布尔型数组（过滤行）、切片（行切片）、布尔型DataFrame（根据条件设置值）</td>
</tr>
<tr>
<td>df.loc[val]</td>
<td>通过标签，选取DataFrame的单个行或一组行</td>
</tr>
<tr>
<td>df.loc[:, val]</td>
<td>通过标签，选取单列或列子集</td>
</tr>
<tr>
<td>df.loc[val1, val2]</td>
<td>通过标签，同时选取行和列</td>
</tr>
<tr>
<td>df.iloc[where]</td>
<td>通过整数位置，从DataFrame选取单个行或行子集</td>
</tr>
<tr>
<td>df.iloc[:, where]</td>
<td>通过整数位置，从DataFrame选取单个列或列子集</td>
</tr>
<tr>
<td>df.iloc[where_i, where_j]</td>
<td>通过整数位置，同时选取行和列</td>
</tr>
<tr>
<td>df.at[label_i, label_j]</td>
<td>通过行和列标签，选取单一的标量</td>
</tr>
<tr>
<td>df.iat[i, j]</td>
<td>通过行和列的位置，选取单一的标量</td>
</tr>
<tr>
<td>reindex</td>
<td>通过标签选取行或列</td>
</tr>
<tr>
<td>get_value, set_value</td>
<td>通过行和列标签选取单一值</td>
</tr>
</tbody>
</table>
<p><strong>算术运算</strong>:算术运算根据行列索引，对齐后运算，运算默认产生浮点数，对齐时缺项填充NaN (空值)。除了用+-*/外，还可以用Series和DataFrame的算术方法，这些方法传入fill_value参数时，可以填充缺省值。比如df1.add(df2, fill_value = 1)。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>add, radd</td>
<td>用于加法（+）</td>
</tr>
<tr>
<td>sub, rsub</td>
<td>用于减法（-）</td>
</tr>
<tr>
<td>div, rdiv</td>
<td>用于除法（/）</td>
</tr>
<tr>
<td>floordiv, rfloordiv</td>
<td>用于底除（//）</td>
</tr>
<tr>
<td>mul, rmul</td>
<td>用于乘法（*）</td>
</tr>
<tr>
<td>pow, rpow</td>
<td>用于指数（**）</td>
</tr>
</tbody>
</table>
<p>比较运算只能比较相同索引的元素，不进行补齐。采用&gt;&lt; &gt;= &lt;= == !=等符号进行的比较运算，产生布尔值。<br>
<strong>排序</strong> ：在排序时，任何缺失值默认都会被放到末尾<br>
<strong>.sort_index(axis=0, ascending=True)</strong>：根据指定轴索引的值进行排序。默认轴axis=0, ascending=True，即默认根据0轴的索引值做升序排序。轴axis=1为根据1轴的索引值排序， ascending=False为降序。<br>
在指定轴上根据数值进行排序，默认升序。<br>
<strong>Series.sort_values(axis=0, ascending=True)</strong>：只能根据0轴的值排序。<br>
<strong>DataFrame.sort_values(by, axis=0, ascending=True)</strong>，参数by为axis轴上的某个索引或索引列表。</p>
<h2 id="pandas数据分析">pandas数据分析</h2>
<h3 id="统计分析-相关分析">统计分析、相关分析</h3>
<p><strong>适用于Series和DataFrame的基本统计分析函数</strong>：传入axis='columns'或axis=1将会按行进行运算。<br>
<strong>.describe()</strong>：针对各列的多个统计汇总，用统计学指标快速描述数据的概要。<br>
<strong>.sum()</strong>：计算各列数据的和<br>
<strong>.count()</strong>：非NaN值的数量<br>
<strong>.mean( )/.median()</strong>：计算数据的算术平均值、算术中位数<br>
<strong>.var()/.std()</strong>：计算数据的方差、标准差<br>
<strong>.corr()/.cov()</strong>：计算相关系数矩阵、协方差矩阵，是通过参数对计算出来的。Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵。<br>
<strong>.corrwith()</strong>：利用DataFrame的corrwith方法，可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算），传入一个DataFrame则会计算按列名配对的相关系数。<br>
<strong>.min()/.max()</strong>：计算数据的最小值、最大值<br>
<strong>.diff()</strong>：计算一阶差分，对时间序列很有效<br>
<strong>.mode()</strong>：计算众数，返回频数最高的那（几）个<br>
<strong>.mean()</strong>：计算均值<br>
<strong>.quantile()</strong>：计算分位数（0到1）<br>
<strong>.isin()</strong>：用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集<br>
适用于Series的基本统计分析函数，DataFrame[列名]返回的是一个Series类型。<br>
<strong>.unique()</strong>：返回一个Series中的唯一值组成的数组。<br>
<strong>.value_counts()</strong>：计算一个Series中各值出现的频率。<br>
<strong>.argmin()/.argmax()</strong>：计算数据最大值、最小值所在位置的索引位置（自动索引）<br>
<strong>.idxmin()/.idxmax()</strong>：计算数据最大值、最小值所在位置的索引（自定义索引）</p>
<h2 id="分组">分组</h2>
<ul>
<li><strong>DataFrame.groupby()</strong>：分组函数，使用方法参考<br>
<a href="https://blog.csdn.net/cymy001/article/details/78300900">Python3pandas库DataFrame的分组,拼接,统计运算等用法(基础整理)</a></li>
<li><strong>pandas.cut()</strong>：根据数据分析对象的特征，按照一定的数值指标，把数据分析对象划分为不同的区间部分来进行研究，以揭示其内在的联系和规律性。类似给成绩设定优良中差，比如：0-59分为差，60-70分为中，71-80分为优秀等等。使用方法参考<br>
<a href="https://blog.csdn.net/weixin_39541558/article/details/80578529">pandas.cut与pandas.qcut使用方法与区别</a><br>
<a href="https://blog.csdn.net/missyougoon/article/details/83986511">pandas中pd.cut()的功能和作用</a></li>
</ul>
<h2 id="pandas读写文本格式的数据">pandas读写文本格式的数据</h2>
<p>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。下表对它们进行了总结，其中read_csv()、read_table()、to_csv()是用得最多的。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>read_csv</td>
<td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td>
</tr>
<tr>
<td>read_table</td>
<td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（'\t'）</td>
</tr>
<tr>
<td>read_fwf</td>
<td>读取定宽列格式数据（也就是说，没有分隔符）</td>
</tr>
<tr>
<td>read_clipboard</td>
<td>读取剪贴板中的数据，可以看作read_table的剪贴板版本。在将网页转换为表格时很有用</td>
</tr>
<tr>
<td>read_excel</td>
<td>从Excel XLS 或 XLSX 文件读取表格数据</td>
</tr>
<tr>
<td>read_hdf</td>
<td>读取pandas写的HDFS文件</td>
</tr>
<tr>
<td>read_html</td>
<td>读取HTML文档中的所有表格</td>
</tr>
<tr>
<td>read_json</td>
<td>读取JSON字符串中的数据</td>
</tr>
<tr>
<td>read_msgpack</td>
<td>二进制格式编码的pandas数据</td>
</tr>
<tr>
<td>read_pickle</td>
<td>读取Python pickle格式中存储的任意对象</td>
</tr>
<tr>
<td>read_sas</td>
<td>读取存储于SAS系统自定义存储格式的SAS数据集</td>
</tr>
<tr>
<td>read_sql</td>
<td>（使用SQLAlchemy）读取SQL查询结果为pandas的DataFrame</td>
</tr>
<tr>
<td>read_stata</td>
<td>读取Stata文件格式的数据集</td>
</tr>
<tr>
<td>read_feather</td>
<td>读取Feather二进制文件格式</td>
</tr>
</tbody>
</table>
<p>工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的参数非常多（read_csv有超过50个参数）。具体使用参考<a href="https://seancheney.gitbook.io/python-for-data-analysis-2nd/di-06-zhang-shu-ju-jia-zai-cun-chu-yu-wen-jian-ge-shi">数据加载、存储与文件格式</a></p>
<h2 id="用pandas来进行数据清洗和准备">用pandas来进行数据清洗和准备</h2>
<p>在数据分析和建模的过程中，相当多的时间要用在数据准备上：加载、清理、转换以及重塑。</p>
<h3 id="处理缺失数据">处理缺失数据</h3>
<p>在许多数据分析工作中，缺失数据是经常发生的。对于数值数据，pandas使用浮点值NaN（np.nan）表示缺失数据，也可将缺失值表示为NA（Python内置的None值）。</p>
<ul>
<li><strong>.info()</strong>：查看数据的信息，包括每个字段的名称、非空数量、字段的数据类型。</li>
<li><strong>.isnull()</strong>：返回一个同样长度的值为布尔型的对象（Series或DataFrame），表示哪些值是缺失的，**.notnull()**为其否定形式。</li>
</ul>
<pre><code class="language-python">import pandas as pd
import numpy as np
In [10]: string_data = pd.Series(['aardvark', 'artichoke', np.nan, None])
In [11]: string_data
Out[11]:
0     aardvark
1    artichoke
2          NaN
3         None
dtype: object

In [14]: string_data.isnull()
Out[14]: 
0    False
1    False
2     True
3     True
dtype: bool
</code></pre>
<ul>
<li><strong>.dropna()</strong>：删除缺失数据。对于Series对象，dropna返回一个仅含非空数据和索引值的Series。对于DataFrame对象，dropna默认删除<strong>含有</strong>缺失值的行；如果想删除<strong>含有</strong>缺失值的列，需传入axis = 1作为参数；如果想删除<strong>全部</strong>为缺失值的行或者列，需传入how='all'作为参数；如果想留下一部分缺失数据，需传入thresh = n作为参数，表示每行至少n个非NA值。</li>
</ul>
<pre><code class="language-python">import pandas as pd
import numpy as np
In [19]: data = pd.DataFrame([[1., 6.5, 3.], [1., NA, NA], [NA, NA, NA], [NA, 6.5, 3.]])
In [20]: data.dropna()
Out[22]: 
     0    1    2
0  1.0  6.5  3.0
#传入how='all'将只丢弃全为NA的那些行：
In [23]: data.dropna(how='all')
Out[23]: 
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
3  NaN  6.5  3.0

In [24]: data[4] = NA
In [25]: data
Out[25]: 
     0    1    2   4
0  1.0  6.5  3.0 NaN
1  1.0  NaN  NaN NaN
2  NaN  NaN  NaN NaN
3  NaN  6.5  3.0 NaN
#用这种方式丢弃列，只需传入axis=1即可：
In [26]: data.dropna(axis=1, how='all')
Out[26]: 
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
2  NaN  NaN  NaN
3  NaN  6.5  3.0
#假设你只想留下一部分观测数据，可以用thresh参数实现此目的：
In [27]: df = pd.DataFrame(np.random.randn(7, 3))
In [28]: df.iloc[:4, 1] = NA
In [29]: df.iloc[:2, 2] = NA
In [30]: df
Out[30]: 
          0         1         2
0 -0.204708       NaN       NaN
1 -0.555730       NaN       NaN
2  0.092908       NaN  0.769023
3  1.246435       NaN -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741

In [32]: df.dropna(thresh=2)
Out[32]: 
          0         1         2
2  0.092908       NaN  0.769023
3  1.246435       NaN -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
</code></pre>
<ul>
<li><strong>.fillna(value,method,limit,inplace)</strong>：填充缺失值。value为用于填充的值（比如0、'a'等）或者是字典（比如{'列':1,'列':8,……}为指定列的缺失数据填充值）；method默认值为ffill，向前填充，bfill为向后填充；limit为向前或者向后填充的最大填充量。inplace默认会返回新对象，修改为inplace=True可以对现有对象进行就地修改。</li>
</ul>
<h3 id="数据转换">数据转换</h3>
<h4 id="替换值">替换值</h4>
<p><strong>.replace(old, new)</strong>：用新的数据替换老的数据，如果希望一次性替换多个值，old和new可以是列表。默认会返回一个新的对象，传入inplace=True可以对现有对象进行就地修改。</p>
<h4 id="删除重复数据">删除重复数据</h4>
<ul>
<li><strong>.duplicated()</strong>：判断各行是否是重复行（前面出现过的行），返回一个布尔型Series。</li>
<li><strong>.drop_duplicates()</strong>：删除重复行，返回删除后的DataFrame对象。默认保留的是第一个出现的行，传入keep='last'作为参数后，则保留最后一个出现的行。</li>
<li>两者都默认会对全部列做判断，在传入列索引组成的列表[ '列1' , '列2' , ……]作为参数后，可以只对这些列进行重复项判断。</li>
</ul>
<h4 id="利用函数或字典进行数据转换">利用函数或字典进行数据转换</h4>
<p><strong>Series.map()</strong>：接受一个函数或字典作为参数。使用map方法是一种实现元素级转换以及其他数据清理工作的便捷方式。</p>
<pre><code class="language-python">import pandas as pd
In [52]: data = pd.DataFrame({'food': ['bacon', 'pulled pork', 'bacon','pastrami', 'corned beef', 'bacon','pastrami', 'honey ham', 'nova lox'],
   ....                       'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]})
meat_to_animal = {
  'bacon': 'pig',  'pulled pork': 'pig',  'pastrami': 'cow',  'corned beef': 'cow',
  'honey ham': 'pig',  'nova lox': 'salmon'
}
#增加一列animal
In [57]: data['animal'] = data['food'].map(meat_to_animal)
In [58]: data
Out[58]: 
          food  ounces  animal
0        bacon     4.0     pig
1  pulled pork     3.0     pig
2        bacon    12.0     pig
3     Pastrami     6.0     cow
4  corned beef     7.5     cow
5        Bacon     8.0     pig
6     pastrami     3.0     cow
7    honey ham     5.0     pig
8     nova lox     6.0  salmon
</code></pre>
<h3 id="dataframe常见函数">DataFrame常见函数</h3>
<p>df.head()：查询数据的前五行<br>
df.tail()：查询数据的末尾5行<br>
pandas.cut()<br>
pandas.qcut() 基于分位数的离散化函数。基于秩或基于样本分位数将变量离散化为等大小桶。<br>
pandas.date_range() 返回一个时间索引<br>
df.apply() 沿相应轴应用函数<br>
Series.value_counts() 返回不同数据的计数值<br>
df.aggregate()<br>
df.reset_index() 重新设置index，参数drop = True时会丢弃原来的索引，设置新的从0开始的索引。常与groupby()一起用<br>
numpy.zeros()</p>
<h2 id="参考">参考</h2>
<p>转自<a href="https://www.jianshu.com/p/840ba135df30">Python pandas用法</a></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#series">Series</a></li>
<li><a href="#dataframe">DataFrame</a>
<ul>
<li><a href="#dataframe%E7%9A%84%E5%88%9B%E5%BB%BA">DataFrame的创建</a></li>
<li><a href="#dataframe%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">DataFrame对象操作</a></li>
</ul>
</li>
<li><a href="#pandas%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">pandas的基本功能</a></li>
<li><a href="#pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">pandas数据分析</a>
<ul>
<li><a href="#%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90-%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90">统计分析、相关分析</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84">分组</a></li>
<li><a href="#pandas%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE">pandas读写文本格式的数据</a></li>
<li><a href="#%E7%94%A8pandas%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E5%92%8C%E5%87%86%E5%A4%87">用pandas来进行数据清洗和准备</a>
<ul>
<li><a href="#%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">处理缺失数据</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2">数据转换</a>
<ul>
<li><a href="#%E6%9B%BF%E6%8D%A2%E5%80%BC">替换值</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE">删除重复数据</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E6%88%96%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2">利用函数或字典进行数据转换</a></li>
</ul>
</li>
<li><a href="#dataframe%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0">DataFrame常见函数</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dingdingtao.github.io/post/pymysql-shu-ju-ku-lian-jie/">
              <h3 class="post-title">
                pymysql数据库连接
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Please&nbsp;&nbsp;contact&nbsp;&nbsp;the&nbsp;&nbsp;authors&nbsp;&nbsp;<a href="https://github.com/dingdingtao" target="_blank">dingdingtao</a>&nbsp;&nbsp;if&nbsp;&nbsp;you&nbsp;&nbsp;have&nbsp;&nbsp;further&nbsp;&nbsp;questions
  <a class="rss" href="https://dingdingtao.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
